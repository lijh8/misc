C++ Core Guidelines

https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c-core-guidelines ,

May 8, 2025

Editors:
Bjarne Stroustrup
Herb Sutter


---


Abstract

The guidelines are focused on relatively high-level issues, such as interfaces,
resource management, memory management, and concurrency. Such rules affect
application architecture and library design. Following the rules will lead to
code that is statically type safe, has no resource leaks, and catches many more
programming logic errors than is common in code today. And it will run fast –
you can afford to do things right.

You will find some of the rules contrary to your expectations or even contrary
to your experience. If we haven’t suggested you change your coding style in any
way, we have failed! Please try to verify or disprove rules! In particular, we’d
really like to have some of our rules backed up with measurements or better
examples.

You will find some of the rules obvious or even trivial. Please remember that
one purpose of a guideline is to help someone who is less experienced or coming
from a different background or language to get up to speed.

Many of the rules are designed to be supported by an analysis tool. Violations
of rules will be flagged with references (or links) to the relevant rule. We do
not expect you to memorize all the rules before trying to write code. One way of
thinking about these guidelines is as a specification for tools that happens to
be readable by humans.

The rules are meant for gradual introduction into a code base. We plan to build
tools for that and hope others will too.


---


In.0: Don’t panic!

The rules emphasize static type safety and resource safety.
For that reason, they emphasize possibilities
for range checking,
for avoiding dereferencing nullptr,
for avoiding dangling pointers, and the systematic use of exceptions (via RAII).


---


In.force: Enforcement

For a start, we have a few profiles corresponding to common needs (desires,
ideals):

type:
    No type violations (reinterpreting a T as a U through casts, unions, or
    varargs)

bounds:
    No bounds violations (accessing beyond the range of an array)

lifetime:
    No leaks (failing to delete or multiple delete) and no access to invalid
    objects (dereferencing nullptr, using a dangling reference).


---


P.4: Ideally, a program should be statically type safe

unions – use variant (in C++17)

casts – minimize their use; templates can help

array decay – use span (from the GSL)

range errors – use span

narrowing conversions
    – minimize their use and use narrow or narrow_cast (from the GSL) where they
      are necessary


---


P.5: Prefer compile-time checking to run-time checking

static_assert can not be turned off by CPPFLAGS += NDEBUG like assert does.

void read(int* p, int n);   // read max n integers into *p
int a[100];
read(a, 1000);    // bad, off the end

void read(span<int> r); // read into the range of integers r
int a[100];
read(a);        // better: let the compiler figure out the number of elements


---


P.6: What cannot be checked at compile time should be checkable at run time

extern void f(int* p);
void g(int n)
{
    // bad: the number of elements is not passed to f()
    f(new int[n]);
}

We can of course pass the number of elements along with the pointer:
a simple typo can introduce a serious error.

extern void f2(int* p, int n);
void g2(int n)
{
    f2(new int[n], m);  // bad: a wrong number of elements can be passed to f()
}

We need to pass the pointer and the number of elements as an integral object:

extern void f4(vector<int>&);   // separately compiled, possibly dynamically loaded
extern void f4(span<int>);      // separately compiled, possibly dynamically loaded
                                // NB: this assumes the calling code is ABI-compatible, using a
                                // compatible C++ compiler and the same stdlib implementation

void g3(int n)
{
    vector<int> v(n);
    f4(v);                     // pass a reference, retain ownership
    f4(span<int>{v});          // pass a view, retain ownership
}

How do we transfer both ownership and all information needed for validating use?

vector<int> f5(int n)    // OK: move
{
    vector<int> v(n);
    // ... initialize v ...
    return v;
}


---


P.7: Catch run-time errors early

void increment1(int* p, int n)    // bad: error-prone
{
    for (int i = 0; i < n; ++i) ++p[i];
}

void use1(int m)
{
    const int n = 10;
    int a[n] = {};
    // ...
    increment1(a, m);   // maybe typo, maybe m <= n is supposed
                        // but assume that m == 20
    // ...
}


void increment2(span<int> p)
{
    for (int& x : p) ++x;
}

void use3(int m)
{
    const int n = 10;
    int a[n] = {};
    // ...
    increment2(a);   // the number of elements of a need not be repeated
    // ...
}


---


P.8: Don’t leak any resources

void f(char* name)
{
    FILE* input = fopen(name, "r");
    // ...
    if (something) return;   // bad: if something == true, a file handle is leaked
    // ...
    fclose(input);
}

Prefer RAII:

void f(char* name)
{
    ifstream input {name};
    // ...
    if (something) return;   // OK: no leak
    // ...
}


---


P.9: Don’t waste time or space

Example, bad
void lower(zstring s)
{
    for (int i = 0; i < strlen(s); ++i) s[i] = tolower(s[i]);
}

it’s better to cache the length outside the loop and not incur that cost each
iteration.

    const auto len = strlen(s);
    for (int i = 0; i < len; ++i) s[i] = tolower(s[i]);


---


I.11: Never transfer ownership by a raw pointer (T*) or reference (T&)

Example Consider:
X* compute(args)    // don't
{
    X* res = new X{};
    // ...
    return res;
}

Who deletes the returned X? The problem would be harder to spot if compute
returned a reference. Consider returning the result by value (use move semantics
if the result is large):

vector<double> compute(args)  // good
{
    vector<double> res(10000);
    // ...
    return res;
}


---


I.13: Do not pass an array as a single pointer

Reason: (pointer, size)-style interfaces are error-prone.
Also, a plain pointer (to array) must rely on some convention to allow the
callee to determine the size.

bad:
void copy_n(const T* p, T* q, int n); // copy from [p:p+n) to [q:q+n)

better:
void copy(span<const T> r, span<T> r2); // copy r to r2

Use zstring and czstring to represent C-style, zero-terminated strings.
But when doing so, use std::string_view or span<char> from the GSL to prevent
range errors.


---


I.22: Avoid complex initialization of global objects

Flag initializers of globals that call non-constexpr functions
Flag initializers of globals that access extern objects


---


I.26: If you want a cross-compiler ABI, use a C-style subset


---


F.4: If a function might have to be evaluated at compile time,
     declare it constexpr

constexpr does not guarantee compile-time evaluation; it just guarantees that
the function can be evaluated at compile time for constant expression arguments
if the programmer requires it or the compiler decides to do so to optimize.

Don’t try to make all functions constexpr. Most computation is best done at run
time.


---


F.6: If your function must not throw, declare it noexcept

Destructors, swap functions, move operations, and default constructors should
never throw.


---


F.7: For general use, take T* or T& arguments rather than smart pointers

Passing a smart pointer transfers or shares ownership and should only be used
when ownership semantics are intended. A function that does not manipulate
lifetime should take raw pointers or references instead.


---


F.8: Prefer pure functions

template<class T>
auto square(T t) { return t * t; }

Has no side effects
    – It does not modify any external state (e.g., global variables,
        static variables, or reference/pointer parameters).

Is deterministic
    – Given the same input, it always produces the same output.


---


F.10: If an operation can be reused, give it a name

Documentation, readability, opportunity for reuse.


---


F.11: Use an unnamed lambda if you need a simple function object
      in one place only

That makes the code concise and gives better locality than alternatives.

auto earlyUsersEnd = std::remove_if(users.begin(), users.end(),
                                    [](const User &a) { return a.id > 100; });


---


F.16: For “in” parameters,
      pass cheaply-copied types by value and others by reference to const

What is “cheap to copy” depends on the machine architecture, but two or three
words (doubles, pointers, references) are usually best passed by value.

void f1(const string& s);  // OK: pass by reference to const; always cheap
void f2(string s);         // bad: potentially expensive
void f3(int x);            // OK: Unbeatable
void f4(const int& x);     // bad: overhead on access in f4()

int multiply(int, int); // just input ints, pass by value

// suffix is input-only but not as cheap as an int, pass by const&
string& concatenate(string&, const string& suffix);

void sink(unique_ptr<widget>);  // input only, and moves ownership of the widget


---


F.17: For “in-out” parameters, pass by reference to non-const

void update(Record& r);  // assume that update writes to r

Some user-defined and standard library types,
such as span<T> or the iterators are cheap to copy and may be passed by value,
while doing so has mutable (in-out) reference semantics:

void increment_all(span<int> a)
{
  for (auto&& e : a)
    ++e;
}


---


F.18: For “will-move-from” parameters, pass by X&& and std::move the parameter

It’s efficient and eliminates bugs at the call site: X&& binds to rvalues,
which requires an explicit std::move at the call site if passing an lvalue.


---


F.19: For “forward” parameters, pass by TP&& and only std::forward the parameter

If the object is to be passed onward to other code and not directly used by this
function, we want to make this function agnostic to the argument const-ness and
rvalue-ness.

template<class F, class... Args>
inline decltype(auto) invoke(F&& f, Args&&... args)
{
    return forward<F>(f)(forward<Args>(args)...);
}


---


F.20: For “out” output values, prefer return values to output parameters

A return value is self-documenting, whereas a & could be either in-out or out-
only and is liable to be misused.

If you have multiple values to return, use a tuple or similar multi-member type.

Assuming that Matrix has move operations (possibly by keeping its elements in a
std::vector):

Matrix operator+(const Matrix& a, const Matrix& b)
{
    Matrix res;
    // ... fill res with the sum ...
    return res;
}

Matrix x = m1 + m2;  // move constructor
y = m3 + m3;         // move assignment

The return value optimization doesn’t handle the assignment case, but the move
assignment does.


---


F.22: Use T* or owner<T*> to designate a single object

In traditional C and C++ code, plain T* is used for many weakly-related purposes,
such as:

Identify a (single) object (not to be deleted by this function)
Point to an object allocated on the free store (and delete it later)
Hold the nullptr
Identify a C-style string (zero-terminated array of characters)
Identify an array with a length specified separately
Identify a location in an array


---


F.24: Use a span<T> or a span_p<T> to designate a half-open sequence

Informal/non-explicit ranges are a source of errors.

X* find(span<X> r, const X& v);    // find v in r

vector<X> vec;
// ...
auto p = find({vec.begin(), vec.end()}, X{});  // find X{} in vec

Ranges are extremely common in C++ code.

Typically, they are implicit and their correct use is very hard to ensure. In
particular, given a pair of arguments (p, n) designating an array [p:p+n), it is
in general impossible to know if there really are n elements to access
following *p.

span<T> and span_p<T> are simple helper classes designating a [p:q) range and a
range starting with p and ending with the first element for which a predicate is
true, respectively.

A span represents a range of elements, but how do we manipulate elements of that
range?

void f(span<int> s)
{
    // range traversal (guaranteed correct)
    for (int x : s) cout << x << '\n';

    // C-style traversal (potentially checked)
    for (gsl::index i = 0; i < s.size(); ++i) cout << s[i] << '\n';

    // random access (potentially checked)
    s[7] = 9;

    // extract pointers (potentially checked)
    std::sort(&s[0], &s[s.size() / 2]);
}

A span<T> object does not own its elements and is so small that it can be passed
by value.


---


F.26: Use a unique_ptr<T> to transfer ownership where a pointer is needed

Using unique_ptr is the cheapest way to pass a pointer safely.

unique_ptr<Shape> get_shape(istream& is)  // assemble shape from input stream
{
    auto kind = read_header(is); // read header and identify the next shape on input
    switch (kind) {
    case kCircle:
        return make_unique<Circle>(is);
    case kTriangle:
        return make_unique<Triangle>(is);
    // ...
    }
}


---


F.27: Use a shared_ptr<T> to share ownership

Using std::shared_ptr is the standard way to represent shared ownership.
That is, the last owner deletes the object.

{
    shared_ptr<const Image> im { read_image(somewhere) };

    std::thread t0 {shade, args0, top_left, im};
    std::thread t1 {shade, args1, top_right, im};
    std::thread t2 {shade, args2, bottom_left, im};
    std::thread t3 {shade, args3, bottom_right, im};

    // detaching threads requires extra care (e.g., to join before
    // main ends), but even if we do detach the four threads here ...
}
// ... shared_ptr ensures that eventually the last thread to
//     finish safely deletes the image


---


F.42: Return a T* to indicate a position (only)

That’s what pointers are good for. Returning a T* to transfer ownership is a
misuse.

Node* find(Node* t, const string& s)  // find s in a binary tree of Nodes
{
    if (!t || t->name == s) return t;
    if ((auto p = find(t->left, s))) return p;
    if ((auto p = find(t->right, s))) return p;
    return nullptr;
}

If it isn’t the nullptr, the pointer returned by find indicates a Node holding s.
Importantly, that does not imply a transfer of ownership of the pointed-to
object to the caller.

Do not return a pointer to something that is not in the caller’s scope;


---


F.43: Never (directly or indirectly) return a pointer or a reference
      to a local object

To avoid the crashes and data corruption that can result from the use of such a
dangling pointer.

After the return from a function its local objects no longer exist:

int* f()
{
    int fx = 9;
    return &fx;  // BAD
}

void g(int* p)   // looks innocent enough
{
    int gx;
    cout << "*p == " << *p << '\n';
    *p = 999;
    cout << "gx == " << gx << '\n';
}

void h()
{
    int* p = f();
    int z = *p;  // read from abandoned stack frame (bad)
    g(p);        // pass pointer to abandoned stack frame to function (bad)
}

This applies to references as well:

int& f()
{
    int x = 7;
    // ...
    return x;  // Bad: returns reference to object that is about to be destroyed
}

This applies only to non-static local variables.
All static variables are (as their name indicates) statically allocated,
so that pointers to them cannot dangle.

The address of a local variable can be “returned”/leaked by a return statement,
by a T& out-parameter, as a member of a returned object, as an element of a
returned array, and more.


---


F.45: Don’t return a T&&

It’s asking to return a reference to a destroyed temporary object. A && is a
magnet for temporary objects.

A returned rvalue reference goes out of scope at the end of the full expression
to which it is returned:

auto&& x = max(0, 1);   // OK, so far
foo(x);                 // Undefined behavior

This kind of use is a frequent source of bugs, often incorrectly reported as a
compiler bug.

Returning an rvalue reference is fine when the reference to the temporary is
being passed “downward” to a callee; then, the temporary is guaranteed to
outlive the function call (see F.18 and F.19). However, it’s not fine when
passing such a reference “upward” to a larger caller scope.


---


F.46: int is the return type for main()

Note that despite its non-void return type,
the main function does not require an explicit return statement.


---


F.48: Don’t return std::move(local)

Returning a local variable implicitly moves it anyway. An explicit std::move is
always a pessimization, because it prevents Return Value Optimization (RVO),
which can eliminate the move completely.

Example, bad
S bad()
{
    S result;
    return std::move(result);
}

Example, good
S good()
{
    S result;
    // Named RVO: move elision at best, move construction at worst
    return result;
}


---


F.49: Don’t return const T

It is not recommended to return a const value. Such older advice is now obsolete;
it does not add value, and it interferes with move semantics.

const vector<int> fct();    // bad: that "const" is more trouble than it is worth


---


F.51: Where there is a choice, prefer default arguments over overloading


---


F.53: Avoid capturing by reference in lambdas that will be used non-locally,
      including returned, stored on the heap, or passed to another thread

If a non-local pointer must be captured, consider using unique_ptr; this handles
both lifetime and synchronization.

// boost.asio, shared_from_this.


---


F.56: Avoid unnecessary condition nesting

Use a guard-clause to take care of exceptional cases and return early.

// Bad: Deep nesting
void foo() {
    ...
    if (x) {
        computeImportantThings(x);
    }
}

// Good: Early return, no redundant else
void foo() {
    ...
    if (!x)
        return;

    computeImportantThings(x);
}


---


C.1: Organize related data into structures (structs or classes)

A simple class without virtual functions implies no space or time overhead.

From a language perspective class and struct differ only in the default
visibility of their members.


---


C.2: Use class if the class has an invariant;
     use struct if the data members can vary independently

An invariant is a logical condition for the members of an object that a
constructor must establish for the public member functions to assume.

After the invariant is established (typically by a constructor) every member
function can be called for the object.

If all data members can vary independently of each other, no invariant is
possible.

// After the invariant is established, every member function can rely on it
// being true when called and must ensure it remains true when they exit.

// The invariant is a contract:
//   The constructor establishes it.
//   Public member functions assume it on entry.
//   Every member function (public or private) preserves it before returning.

// Example:
// In a Date class, an invariant might be that the day must be between 1 and 31
// (for simplicity, ignoring months), and the month must be between 1 and 12.
// The constructor must enforce this, and all member functions (like set_day or
// set_month) must ensure the condition remains true after they execute.


---


C.9: Minimize exposure of members

protected data is a bad idea.
Prefer the order public members before protected members before private members;


---


C.10: Prefer concrete types over class hierarchies

A concrete type is fundamentally simpler than a type in a class hierarchy:
easier to design,
easier to implement,
easier to use,
easier to reason about,
smaller, and
faster.
You need a reason (use cases) for using a hierarchy.

If a class is part of a hierarchy, we (in real code if not necessarily in small
examples) must manipulate its objects through pointers or references. That
implies
more memory overhead,
more allocations and deallocations, and
more run-time overhead
to perform the resulting indirections.

The use of indirection is fundamental for run-time polymorphic interfaces.


---


C.ctor: Constructors, assignments, and destructors

These functions control the lifecycle of objects: creation, copy, move, and destruction.

By default, C++ treats classes as value-like types, but not all types are value-like.

// a complete and correct string example of rule of five
//
// the assignment operator with parameter of value type can replace
// both copy and move assignment. this makes it rule of four.
//
// https://en.cppreference.com/w/cpp/language/rule_of_three ,


---


C.20: If you can avoid defining default operations, do

struct Named_map {
public:
    explicit Named_map(const string& n) : name(n) {}
    // no copy/move constructors
    // no copy/move assignment operators
    // no destructor
private:
    string name;
    map<int, int> rep;
};

Named_map nm("map"); // construct
Named_map nm2 {nm};  // copy construct

Since std::map and string have all the special functions,
no further work is needed.

// This means data members handle their own resource management (via RAII),
// allowing the class to follow the Rule of Zero.

This is known as “the rule of zero”.


---


C.21: If you define or =delete any copy, move, or destructor function,
      define or =delete them all

This is known as “the rule of five.”

Writing these functions can be error-prone. Note their argument types:

class X {
public:
    // ...
    virtual ~X() = default;               // destructor (virtual if X is meant to be a base class)
    X(const X&) = default;                // copy constructor
    X(X&&) noexcept = default;            // move constructor
    X& operator=(const X&) = default;     // copy assignment
    X& operator=(X&&) noexcept = default; // move assignment
};

A minor mistake (such as a misspelling, leaving out a const, using & instead of
&&, or leaving out a special function) can lead to errors or warnings.


---


C.dtor: Destructors

“Does this class need a destructor?” is a surprisingly insightful design
question.
For most classes the answer is “no” either because the class holds no resources
or because destruction is handled by the rule of zero;
that is, its members can take care of themselves as concerns destruction.


---


C.30: Define a destructor if a class needs an explicit action
      at object destruction

Only define a non-default destructor if a class needs to execute code that is
not already part of its members’ destructors.


---


C.35: A base class destructor should be either public and virtual,
      or protected and non-virtual


To prevent undefined behavior.
If the destructor is public, then calling code can attempt to destroy a derived
class object through a base class pointer, and the result is undefined if the
base class’s destructor is non-virtual.


---


C.36: A destructor must not fail

The standard library requires that all classes it deals with have destructors
that do not exit by throwing.

Declare a destructor noexcept. That will ensure that it either completes
normally or terminates the program.


---


C.37: Make destructors noexcept

A destructor must not fail. If a destructor tries to exit with an exception,
it’s a bad design error and the program had better terminate.


---


C.41: A constructor should create a fully initialized object

A constructor establishes the invariant for a class.
A user of a class should be able to assume that a constructed object is usable.

If a constructor acquires a resource (to create a valid object),
that resource should be released by the destructor.
The idiom of having constructors acquire resources and destructors release them
is called RAII (“Resource Acquisition Is Initialization”).


---


C.43: Ensure that a copyable class has a default constructor

Many language and library facilities rely on default constructors to initialize
their elements, e.g. T a[10] and std::vector<T> v(10).
A default constructor often simplifies the task of defining a suitable
moved-from state for a type that is also copyable.


---


C.45: Don’t define a default constructor that only initializes data members;
      use default member initializers instead

Using default member initializers lets the compiler generate the function for
you. The compiler-generated function can be more efficient.

class X1 { // BAD: doesn't use member initializers
    string s;
    int i;
public:
    X1() :s{"default"}, i{1} { }
    // ...
};

class X2 {
    string s {"default"};
    int i {1};
public:
    // use compiler-generated default constructor
    // ...
};

// C++ Primer 5th, 2.6.1: in-class initialization


---


C.46: By default, declare single-argument constructors explicit

To avoid unintended conversions.

class String {
public:
    String(int);   // BAD
    // ...
};

String s = 10;   // surprise: string of size 10

Single-argument constructors should be declared explicit.
Good single argument non-explicit constructors are rare in most code bases.

// C.164: implicit conversion operators


---


C.52: Use inheriting constructors to import constructors into a derived class
      that does not need further explicit initialization

#include <iostream>

struct A {
  A() { std::cout << __LINE__ << ":" << __func__ << "\n"; }
  A(int x) { std::cout << __LINE__ << ":" << __func__ << ": " << x << "\n"; }
  virtual ~A() { std::cout << __LINE__ << ":" << __func__ << "\n"; }

  A(const A &) = default;
  A(A &&) noexcept = default;
  A &operator=(const A &) = default;
  A &operator=(A &&) noexcept = default;
};

struct B : A {
  B() { std::cout << __LINE__ << ":" << __func__ << "\n"; }
  using A::A;
};

int main() {
  B b1;
  B b2(3); // using A::A
  std::cout << "main\n";
}

The base class defines a constructor with an int parameter `A(int)`.
The child class does not define a constructor with an int parameter `B(int)`,
write `using A::A` in the child class,
it can define object passing an int like base class.


---


C.80: Use =default if you have to be explicit about using the default semantics

class Tracer {
    string message;
public:
    Tracer(const string& m) : message{m} { cerr << "entering " << message << '\n'; }
    ~Tracer() { cerr << "exiting " << message << '\n'; }

    Tracer(const Tracer&) = default;
    Tracer(Tracer&&) noexcept = default;
    Tracer& operator=(const Tracer&) = default;
    Tracer& operator=(Tracer&&) noexcept = default;
};

Because we defined the destructor, we must define the copy and move operations.
The = default is the best and simplest way of doing that.

Example, bad
class Tracer2 {
    string message;
public:
    Tracer2(const string& m) : message{m} { cerr << "entering " << message << '\n'; }
    ~Tracer2() { cerr << "exiting " << message << '\n'; }

    Tracer2(const Tracer2& a) : message{a.message} {}
    Tracer2& operator=(const Tracer2& a) { message = a.message; return *this; }
    Tracer2(Tracer2&& a) noexcept :message{a.message} {}
    Tracer2& operator=(Tracer2&& a) noexcept { message = a.message; return *this; }
};

// Because the Tracer, Tracer2 comply with rule of zero.
// Tracer2 just wants to print some constructing and destructing messages,
// so the copy and move operations can be omitted.


---


C.82: Don’t call virtual functions in constructors and destructors


---


C.103: Give a container an initializer list constructor

People expect to be able to initialize a container with a set of values.

Sorted_vector<int> sv {1, 3, -1, 7, 0, 0}; // Sorted_vector sorts elements as needed

// https://en.cppreference.com/w/cpp/container/vector/vector.html ,
vector( std::initializer_list<T> init,
        const Allocator& alloc = Allocator() );

// C++11 initializer list syntax:
std::vector<std::string> words1{"the", "frogurt", "is", "also", "cursed"};


---


C.109: If a resource handle has pointer semantics, provide * and ->

That’s what is expected from pointers. Familiarity.

// std::unique_ptr, std::shared_ptr,


---


C.131: Avoid trivial getters and setters

A trivial getter or setter adds no semantic value;
the data item could just as well be public.

class Point {   // Bad: verbose
    int x;
    int y;
public:
    Point(int xx, int yy) : x{xx}, y{yy} { }
    int get_x() const { return x; }
    void set_x(int xx) { x = xx; }
    int get_y() const { return y; }
    void set_y(int yy) { y = yy; }
    // no behavioral member functions
};

Consider making such a class a struct – that is,
a behaviorless bunch of variables, all public data and no member functions.

struct Point {
    int x {0};
    int y {0};
};

whether there would be any difference beyond syntax if the getter/setter was a
public data member instead.
non-trivial semantics would be: maintaining a class invariant or converting
between an internal type and an interface type.


---


C.138: Create an overload set for a derived class and its bases with using

// C.52
// https://en.cppreference.com/w/cpp/language/using_declaration.html ,


---


C.145: Access polymorphic objects through pointers and references

// through pointers or references to base or parent class.

#include <iostream>

class Base {
public:
  virtual void f() { std::cout << "Base::f()\n"; }
  virtual ~Base() = default;
};

class Derived : public Base {
public:
  void f() override { std::cout << "Derived::f()\n"; }
};

// Parameter: Reference to Base class.
// It can then be called with argument of reference to Base or Derived class.
void foo(Base &r) {
  r.f();
  return;
}

int main() {
  Base b;
  Derived d;

  // Pointer to Base class.
  // It can then be assigned with pointer to Base or Derived class.
  Base *p;

  p = &b;
  p->f(); // Base::f

  p = &d;
  p->f(); // Derived::f

  foo(b);
  foo(d);
}


---


C.149: Use unique_ptr or shared_ptr to avoid forgetting to delete objects
       created using new

void use(int i)
{
    auto p = new int {7};           // bad: initialize local pointers with new
    auto q = make_unique<int>(9);   // ok: guarantee the release of the memory-allocated for 9
    if (0 < i) return;              // maybe return and leak
    delete p;                       // too late
}


---


C.164: Avoid implicit conversion operators

Implicit conversions can be essential (e.g., double to int) but often cause
surprises (e.g., String to C-style string).

struct S1 {
    string s;
    // ...
    operator char*() { return s.data(); }  // BAD, likely to cause surprises
};

// C.46: single-argument constructors explicit


---


C.165: Use using for customization points

namespace N {
    My_type X { /* ... */ };
    void swap(X&, X&);   // optimized swap for N::X
    // ...
}

void f1(N::X& a, N::X& b)
{
    std::swap(a, b);   // probably not what we wanted: calls std::swap()
}

we typically want the specific function if it exists and
the general function if not.

void f3(N::X& a, N::X& b)
{
    using std::swap;  // make std::swap available
    swap(a, b);        // calls N::swap if it exists, otherwise std::swap
}


---


C.170: If you feel like overloading a lambda, use a generic lambda

auto h = [](auto) { /* ... */ };   // OK


---


R: Resource management

A resource is anything that must be acquired and (explicitly or implicitly)
released, such as memory, file handles, sockets, and locks.

An entity that is responsible for releasing a resource is called an owner.


---


R.1: Manage resources automatically using resource handles and
     RAII (Resource Acquisition Is Initialization)

To avoid leaks and the complexity of manual resource management.
C++’s language-enforced constructor/destructor symmetry mirrors the symmetry
inherent in resource acquire/release function pairs such as
fopen/fclose, lock/unlock, and new/delete.

Whenever you deal with a resource that needs paired acquire/release function
calls, encapsulate that resource in an object that enforces pairing for you –
acquire the resource in its constructor, and release it in its destructor.

Example, bad Consider:
void send(X* x, string_view destination)
{
    auto port = open_port(destination);
    my_mutex.lock();
    // ...
    send(port, x);
    // ...
    my_mutex.unlock();
    close_port(port);
    delete x;
}

Example Consider:
class Port {
    PortHandle port;
public:
    Port(string_view destination) : port{open_port(destination)} { }
    ~Port() { close_port(port); }
    operator PortHandle() { return port; }

    // port handles can't usually be cloned, so disable copying and assignment if necessary
    Port(const Port&) = delete;
    Port& operator=(const Port&) = delete;
};

void send(unique_ptr<X> x, string_view destination)  // x owns the X
{
    Port port{destination};            // port owns the PortHandle
    lock_guard<mutex> guard{my_mutex}; // guard owns the lock
    // ...
    send(port, x);
    // ...
} // automatically unlocks my_mutex and deletes the pointer in x

Where a resource is “ill-behaved” in that it isn’t represented as a class with a
destructor, wrap it in a class or use finally.


---
