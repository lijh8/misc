
// c/c++ source file

source file:
declarations
type declaration
variable declaration //global
function declaration

function:
variable declaration //local
statements
expressions statement
control statement
assignment statement


---


# Minimal Makefile

# build dynamic library with -fPIC -shared
CFLAGS   = -g # -O3 -fPIC # CXXFLAGS for .cpp
CPPFLAGS = -MMD -MP # -I../foo -DNDEBUG
LDFLAGS  = # -L../foo -shared
LDLIBS   = # -lfoo
#CC      = $(CXX) # link with CXX for .cpp

# target name is basename of one of the source files
main : $(patsubst %.c,%.o,$(wildcard *.c)) # .cpp
-include *.d
clean : ; -rm -fr *.o *.d main
.PHONY : clean


---


// c/c++ initialization

//  =  for initialization (and assignment): basic types
//char, int, float, double, pointers, array element and structure
//assignment
int n = 123;

//  {}  for initialization: array, structure, c++ vector
int a1[10] = {0};
int a2[] = “hello”; //a2 with nul
struct point {int x,y} pt = {10, 20};
vector<string> articles = {"a", "an", "the"};

//  ()  for initialization: c++ class type
//library string without nul, string::c_str() with nul
string s1("hello");
string s2 = "hello";
string s3(10, 'c');
string s4 = string(10, 'c');

// if struct has more members than initializer,
// or array has more elements than initializers,
// the rest without initializers will be zero.
char arr1[10] = {'a','b','c'}; //
char arr2[10] = "abc";
struct T{ int a; int b; int c; } t = {1}; //


---


// string and array

/* const*/ char *ptr = "hello"; // pointer const string literal
// *ptr = 'H'; // error
// ptr[0] = 'H'; // error

char arr[] = "hello";
*ar = 'H'; //ok
arr[0] = 'H'; //ok


---


// integral promotion

#include <iostream>
#include <climits>

int main()
{
    unsigned char       a = UCHAR_MAX;
    unsigned short      b = USHRT_MAX;
    int                 c = INT_MAX;
    unsigned int        d = UINT_MAX;
    unsigned long       e = ULONG_MAX;
    unsigned long long  f = ULLONG_MAX;

    std::cout << UCHAR_MAX  << "\t: " << UCHAR_MAX + 1  << "\n";
    std::cout << USHRT_MAX  << "\t: " << USHRT_MAX + 1  << "\n";
    std::cout << INT_MAX    << "\t: " << INT_MAX + 1  << "\n"; // overflow
    std::cout << UINT_MAX   << "\t: " << UINT_MAX + 1  << "\n";
    std::cout << ULONG_MAX  << "\t: " << ULONG_MAX + 1  << "\n";
    std::cout << ULLONG_MAX << "\t: " << ULLONG_MAX + 1  << "\n";

    std::cout << '\n';

    std::cout << a  << "\t: " << a + 1  << "\n";
    std::cout << b  << "\t: " << b + 1  << "\n";
    std::cout << c  << "\t: " << c + 1  << "\n";
    std::cout << d  << "\t: " << d + 1  << "\n";
    std::cout << e  << "\t: " << e + 1  << "\n";
    std::cout << f  << "\t: " << f + 1  << "\n";

}


---


https://c-faq.com/expr/intoverflow1.html

    int a = INT_MAX;
    int b = INT_MAX;
    long int c = a * b; // error
    long int c = (long int)(a * b); // error, conversion, it happens too late

Under C's integral promotion rules, the multiplication is carried out
using int arithmetic, and the result may overflow or be truncated before
being promoted and assigned to the long int left-hand side.
Use an explicit cast on at least one of the operands to force long arithmetic:

    int a = INT_MAX;
    int b = INT_MAX; // or, long b = INT_MAX;
    long int c = (long int)a * b; // ok, explicit type conversion on operand
    long int d = ((long int)a) * b; // ok, explicit type conversion on operand
    long int e = (1L * a) * b;


---


https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4950.pdf ,

sec 6.8.2 :

Note 2 : Unsigned arithmetic does not overflow.
Overflow for signed arithmetic yields undefined behavior (7.1).

// or, underflow and overflow is well defined in unsigned integers

    auto x = UINT_MAX; // 4294967295
    auto x2 = 5 - UINT_MAX; // 6
    auto x3 = 5 - (long)UINT_MAX; // -4294967290

// leetcode 58. Length of Last Word
// https://leetcode.cn/problems/length-of-last-word/description/

    #include <iostream>
    #include <vector>
    #include <string>
    using namespace std;

    int lengthOfLastWord(string s) {
        auto a = s.find_last_not_of(' ');
        auto b = s.find_last_of(' ', a);
        return a - b;
    }

    int main() {
        std::cout << lengthOfLastWord("hello") << "\n"; // 5 - string::npos == 6 // ?
        // std::cout << lengthOfLastWord("hello guys") << "\n";
        // std::cout << lengthOfLastWord(" hello c++ ") << "\n";
        return 0;
    }


---


"                                                                   "
"  K&R C 2nd, A4.2:                                                 "
"  obey the laws of arithmetic modulo 2^n                           "
"  arithmetic on unsigned quantities can never overflow             "
"                                                                   "
"  unsigned integers                                                "
"                                                                   "
"          M  M                                                     "
"          A  I                                                     "
"          X, N,                                                    "
"             0                                                     "
"          *  *   1                                                 "
"       *        *                                                  "
"      *          * 2                                               "
"      *          *                                                 "
"       *        *                                                  "
"          *  *                                                     "
"                                                                   "
"  ---------------------------------------------------------------  "
"                                                                   "
"  K&R C 2nd, A6.2:                                                 "
"  When any integer is converted to a signed type,                  "
"  the value is unchanged if it can be represented in the new type  "
"  and is implementation-defined otherwise.                         "
"                                                                   "
"  signed int                                                       "
"                                                                   "
"  MIN, ..  -2,-1, 0, 1, 2, ..  MAX,                                "
"   *  *  *  *  *  *  *  *  *  *  *                                 "
"                                                                   "


---


https://c-faq.com/misc/intovf.html

How can I ensure that integer arithmetic doesn't overflow?

The usual approach is to test the operands against the limits in the
header file <limits.h> before doing the operation. For example,
here is a ``careful'' addition function:

int
chkadd(int a, int b)
{
    if(INT_MAX - b < a) {
        fputs("int overflow\n", stderr);
        return INT_MAX;
    }
    return a + b;
}

Here is a complete set of three functions for ``careful''
addition, subtraction, and multiplication.
(Note: these functions are still not perfect, and may fail if invoked on
various edge cases, such as the smallest negative integer, INT_MIN.)

#include <stdio.h>
#include <limits.h>

int
chkadd(int a, int b)
{
    if(b < 0)
        return chksub(a, -b);
    if(INT_MAX - b < a) {
        fputs("int overflow\n", stderr);
        return INT_MAX;
    }
    return a + b;
}

int
chksub(int a, int b)
{
    if(b < 0)
        return chkadd(a, -b);
    if(INT_MIN + b > a) {
        fputs("int underflow\n", stderr);
        return INT_MIN;
    }
    return a - b;
}

int
chkmul(int a, int b)
{
    int sign = 1;
    if(a == 0 || b == 0) return 0;
    if(a < 0) { a = -a; sign = -sign; }
    if(b < 0) { b = -b; sign = -sign; }
    if(INT_MAX / b < a) {
        fputs("int overflow\n", stderr);
        return (sign > 0) ? INT_MAX : INT_MIN;
    }
    return sign * a * b;
}


---


// https://en.cppreference.com/w/cpp/language/implicit_conversion

prvalues of small integral types (such as char) may be converted to
prvalues of larger integral types (such as int).

In particular, arithmetic operators do not accept types smaller
than int as arguments, and integral promotions are automatically applied
after lvalue-to-rvalue conversion, if applicable.


// K&R C 2nd:

2.3 Constants:
An integer constant like 1234 is an int.
A long constant is written with a terminal 1 (ell) or L, as in 123456789L;
an integer too big to fit into an int will also be taken as a long.
Unsigned constants are written with a terminal u or U,
and the suffix ul or UL indicates unsigned long.

2.7 Type Conversions:
Otherwise, convert char and short to int.

A.6.1 Integral Promotion:
A character, a short integer, ..is converted to int;


---


// temporary

#include <iostream>

int main() {
    char c1 = toupper(std::string_view("abc")[0]);    //ok
    char c2 = toupper(std::string("abc").c_str()[0]); //ok

    // Temporary of an temporary
    const char *a = (std::string("abc")).c_str(); //error

    // https://en.cppreference.com/w/cpp/language/lifetime
    // lifetime of a temporary object may be extended by binding to
    // a const lvalue reference
    const std::string &b = std::string("abc");    //ok
    const char *c3 = b.c_str();                   //ok
    std::cout << c3 << "\n";

    //or, use an intermediate temporary variable
    std::string tmp = std::string("abc");
    const char *p = tmp.c_str();

}


---


// struct literal, temporary,

struct T{};
(struct T){} = (struct T){};

https://en.cppreference.com/w/c/language/value_category :
compound literals, which look similar, are lvalues

https://en.cppreference.com/w/c/language/compound_literal :
The value category of a compound literal is lvalue (its address can be taken)


---


//https://en.cppreference.com/w/cpp/language/expressions#Literals
//Literals are the tokens of a C++ program that represent constant values
//embedded in the source code.

//C: temporary struct is struct literal. it is constant.
//C: can not change member data of temporary.
//C++: temporary is object constructed by constructor.
//C++: can not change member data of temporary.
//C++: can not invoke builtin operator & on temporary.
//C++: member functions and operators can be invoked on temporary objects.

typedef struct T {
    int num;
} T;

T f1()
{
    return (T){.num = 123,};
}

//lvalue reference requires const if argument is temporary
void f2_accept_temp(const T &t)
{
}

//rvalue reference
void f3(T &&t)
{
}

int main()
{
    //c: return value is struct literal
    //f1() = f1(); //error: expression is not assignable
    //f1().num++; //error: expression is not assignable
    //T *p = &f1(); //error: cannot take the address of an rvalue of type 'T' (aka 'struct T')

    //c++: return value is class/struct object
    f1() = f1(); //ok, invoke member operator= of the class
    //f1().num++; //error: expression is not assignable
    //T *p = &f1(); //error: taking the address of a temporary object of type 'T' [-Waddress-of-temporary]

    int n = f1().num;
    T t = f1();

    f2_accept_temp((T){});
    f3((T){});

    return 0;
}


---


https://en.cppreference.com/w/c/language/lifetime

Temporary lifetime
Struct and union objects with array members (either direct or members of
nested struct/union members) that are designated by non-lvalue expressions,
have temporary lifetime. Temporary lifetime begins when the expression
that refers to such object is evaluated and ends at
the next sequence point (until C11)
when the containing full expression or full declarator ends (since C11).

Any attempt to modify an object with temporary lifetime results in undefined behavior.

struct T { double a[4]; };
struct T f(void) { return (struct T){3.15}; }
double g1(double* x) { return *x; }
void g2(double* x) { *x = 1.0; }

int main(void)
{
    double d = g1(f().a); // C99: UB access to a[0] in g1 whose lifetime ended
                          //      at the sequence point at the start of g1
                          // C11: OK, d is 3.15
    g2(f().a); // C99: UB modification of a[0] whose lifetime ended at the sequence point
               // C11: UB attempt to modify a temporary object
}


---


// Sequence point occurs:

$ 7.12.1, C A reference manual, 5th
- at the end of a full expression--that is,
    an initializer, an expression statement, the expression in a return
    statement, and the control expressions in a conditional, iterative,
    or switch statement (including each expression in a for statement)
- after the first operand of a &&, ||, ?:, or comma operator
- after the evaluation of the arguments and function expression in a
    function call


---


// https://c-faq.com/expr/seqpoints.html

Between the previous and next sequence point an object shall have its
stored value modified at most once by the evaluation of an expression.
Furthermore, the prior value shall be accessed only to determine the
value to be stored.

- full expression or expression statement has sequence point at its end,
  subexpresion has sequence point only there is  &&  ||  :?  ,  in it.

- a variable can be modified only once within one single sequence point.

- expressions like i = i + 1 which use and modify i but only modify it later
when it's reasonably easy to ensure that the final store of the final value
(into i, in this case) doesn't interfere with the earlier accesses.


    i = i++;    // error
    i++ * i++;  // error
    i = i + 1;  // ok
    i = i + 1;  // ok
    i++ && i++; // ok


---


https://c-faq.com/expr/confused.html

If an object (as defined above) appears more than once in an expression,
and is the object modified in the expression, make sure that all
appearances of the object which fetch its value participate in the
computation of the new value which is stored.
This rule allows the expression

    i = i + 1

because although the object i appears twice and is modified,
the appearance (on the right-hand side) which fetches i's old value
is used to compute i's new value.


---


// 1. function argument pass by value
// will not change the argument passed by caller
void f1(int x){
    x++;
}

// 2. function argument pass by const reference
// (1) will not change the actual argument passed by caller
void f2(const int &x){
    // (2) can not change formal parameter declared as const too
    // x++; // error: assign to const

    auto y = x; // make a copy
    y++; // ok
}

// 3. function argument pass by reference
// will change the actual argument passed by caller
void f3(int &x){
    x++;
}

int main(){
    int num = 10;
    f1(num); // num is not changed
    f2(num); // num is not changed
    f3(num); // num is changed
    return 0;
}


---


https://en.cppreference.com/w/cpp/language/rule_of_three ,

// rule of three / five /zero

class rule_of_five
{
    char* cstring; // raw pointer used as a handle to a
                   // dynamically-allocated memory block
public:
    explicit rule_of_five(const char* s = "") : cstring(nullptr)
    {
        if (s)
        {
            std::size_t n = std::strlen(s) + 1;
            cstring = new char[n];      // allocate
            std::memcpy(cstring, s, n); // populate
        }
    }

    ~rule_of_five()
    {
        delete[] cstring; // deallocate
    }

    rule_of_five(const rule_of_five& other) // copy constructor
        : rule_of_five(other.cstring) {}

    rule_of_five(rule_of_five&& other) noexcept // move constructor
        : cstring(std::exchange(other.cstring, nullptr)) {}

    rule_of_five& operator=(const rule_of_five& other) // copy assignment
    {
        return *this = rule_of_five(other);
    }

    rule_of_five& operator=(rule_of_five&& other) noexcept // move assignment
    {
        std::swap(cstring, other.cstring);
        return *this;
    }

// alternatively, replace both assignment operators with
//  rule_of_five& operator=(rule_of_five other) noexcept
//  {
//      std::swap(cstring, other.cstring);
//      return *this;
//  }

};


/*

notes:

1. delegating constructor:

    rule_of_five(rule_of_five&& other) noexcept // move constructor
        : cstring(std::exchange(other.cstring, nullptr)) {}

2. inside the copy assignment,
   the move assignment is called on the temporary object:

    rule_of_five& operator=(const rule_of_five& other) // copy assignment
    {
        return *this = rule_of_five(other);
    }

3. copy and swap:
   pass arguments by value to function,
   for the single value parameter, copy or move constructor is called.
   it will call copy or move constructor instead of assignment operator.
   assignment operator is for assigning a value to an existing variable.
   constructor is for creating a new parameter object.

   c++ primer 5th, 13.3: copy and swap.
   c++ primer 5th, 13.1.1: parameters that have a nonreference type are copy initialized.

    rule_of_five& operator=(rule_of_five other);

    rule_of_five t1, t2;
    t2 = t1;
    t2 = std::move(t1);

*/


---


// c++11 rvalue reference, move operation semantics,
// bind rvalue reference to element in container,
// move element out of container,

#include <iostream>
#include <vector>
#include <utility>

void f(std::string &&s){
    std::string t = std::move(s); // move
}

void f(std::string &s){ // ok too
    std::string t = std::move(s); // move
}

int main() {
    std::vector<std::string> v1 = {"hello", "world", "abc"};
    auto elem = std::move(v1[0]); // 1. move
    f(std::move(v1[1])); // 2. move
    f(v1[2]); // 3. move

    // ---

    std::vector<std::string> v2 = {"hello", "world", "abc"};
    std::vector<std::string> v3;
    for (auto &&e : v2) {
    // for (auto &e : v2) { // ok too
        v3.emplace_back(std::move(e)); // 4. move
    }

    return 0;
}


---


// find possible multiple occurences of substring in a range
// in a larger string in c++.


int main() {
  // std::string haystack = "abaCabaCabaCaba";
  // std::string needle = "aba";

  std::string haystack = "abababababababa";
  std::string needle = "aba";

  const auto first = 1; // 0;                              // 1;
  const auto last = 13; // end(haystack) - begin(haystack); // 13;

  for (auto i = begin(haystack) + first, j = begin(haystack) + last; i != j;) {
    if (auto k = search(i, j, begin(needle), end(needle)); k != j) {
      std::cout << k - begin(haystack) << ",";
      i = end(needle) - begin(needle) + k;
    } else {
      i++;
    }
  }
  std::cout << "\n";
  return 0;
}


/*
abaCabaCabaCaba, sub: aba
0,4,8,12,
4,8,

abababababababa, sub: aba
0,4,8,12,
2,6,10,
*/


// 1. the substring needle could contain more than one characters,
//     this eliminates the std::string::find_first_of, std::find_first_of,
//     because both can search for one single character from a set in a larger string.

// 2. i need to search in a range in the larger string for a substring,
//     this eliminates the std::string::find, because it has no way to specify that range.

// 3. std::search is the only way which can fulfill the requirement.


//---


/*
std::string s = "aaaaabaaaaab";
std::string sub = "aaaaa";
std::search_n(std::begin(s), std::end(s), 5, 'a');
std::search(std::begin(s), std::end(s), begin(sub), end(sub));
*/

int main() {
  std::string str = "aaaaabaaaaab";
  std::string sub = "aaaaa"; // 5, 'a'
  constexpr int len = 5;

  for (auto i = begin(str); i != end(str); i++) {
    auto j = search_n(i, end(str), len, 'a');
    if (j != end(str)) {
      std::cout << __LINE__ << ": " << j - begin(str) << "\n";
      i = j;
    }
  }

  for (auto i = begin(str); i != end(str); i++) {
    auto j = search(i, end(str), begin(sub), end(sub));
    if (j != end(str)) {
      std::cout << __LINE__ << ": " << j - begin(str) << "\n";
      i = j;
    }
  }

  return 0;
}


//---


// Converting from Iterator to Reverse Iterator.
#include <iostream>
#include <iterator>
#include <vector>

int main() {
  std::vector<int> vec = {1, 2, 3, 4, 5};
  auto it = vec.begin() + 2;
  std::cout << *it << "\n"; // 3
  // std::reverse_iterator<decltype(it)> rev_it(it); // ok
  auto rev_it = std::make_reverse_iterator(it); // ok
  std::cout << *rev_it << "\n";                 // 2
  rev_it--;                                     // ok
  std::cout << *rev_it << "\n";                 // 3, same element

  return 0;
}

// Converting from Reverse Iterator to Iterator.
// A reverse iterator points to the element that precedes the one it actually
// represents. It is conceptually working backwards. Its .base() method will
// return an iterator that points to the next element in the underlying
// container (which means the original element before the reverse iteration).

int main22() {
  std::vector<int> vec = {1, 2, 3, 4, 5};
  auto rev_it = vec.rbegin() + 2;
  std::cout << *rev_it << "\n"; // 3
  auto it = rev_it.base();
  std::cout << *it << "\n"; // 4

  it--;                     // ok
  std::cout << *it << "\n"; // 3, same element

  return 0;
}


//---


// reserve:

// std::string str;
// str.reserve(100); // capacity == 100; size == 0;
// std::vector<int> vec;
// vec.reserve(100); // capacity == 100; size == 0;


// initialize object with size:

// if you specify a size, the allocation will typically occur once,
// similar to calling reserve(), but it also initializes all elements.
// reserve allocate storage but do not initialize elements.

// std::string str(100, ' '); // size == 100
// std::vector<int> v(100);   // size == 100


//---


// cppreference.com, html-book-20240610/reference/en/cpp/algorithm/search_n.html:

template<class Container, class Size, class T>
constexpr bool consecutive_values(const Container& c, Size count, const T& v)
{
    return std::search_n(std::begin(c), std::end(c), count, v) != std::end(c);
}

int main()
{
    constexpr char sequence[] = ".0_0.000.0_0.";

    static_assert(consecutive_values(sequence, 3, '0'));

    for (int n : {4, 3, 2})
        std::cout << std::boolalpha
                  << "Has " << n << " consecutive zeros: "
                  << consecutive_values(sequence, n, '0') << '\n';

    std::vector<std::complex<double>> nums{{4, 2}, {4, 2}, {1, 3}};
    #ifdef __cpp_lib_algorithm_default_value_type
        auto it = std::search_n(nums.cbegin(), nums.cend(), 2, {4, 2});
    #else
        auto it = std::search_n(nums.cbegin(), nums.cend(), 2, std::complex<double>{4, 2});
    #endif
    assert(it == nums.begin());
}

1. because the consecutive_values is constexpr so static_assert can be used on the call to consecutive_values,
because sequence is constexpr so consecutive_values can be constexpr,

2. if the input sequence data is from user input at runtime, then sequence can not be constexpr,
and consecutive_values can not be constexpr, and static_assert can not be used on the call to consecutive_values,

---

assert from the cassert will be ignored when NDEBUG is defined.
static_assert can not be ignored, and it works at compile time when writing the program.
static_assert evaluates expression at compile-time.

---

value qualified with keyword const does not meet the requirement of compile time evaluation.
value qualified with keyword constexpr, consteval do meet the requirement of compile time evaluation.

---

const:
Indicates that a variable's value cannot be modified after its initialization.
it means it is a read-only value.
it is not compile-time constant value;

constexpr:
When applied to variables,
it means the variable is constant and must be initialized with a constant expression.
When applied to functions,
it means that the function can be evaluated at compile time if given constant expressions as arguments.

consteval:
indicates that a function is a compile-time function and
must always produce a compile-time constant when called.

constinit:
Guarantees that a variable is initialized at compile time
but does not enforce that it is immutable.
It can be modified after initialization, unlike const.
unlike constexpr, it does not require the variable to be truly constant throughout its lifetime.


---


```
  {
    std::vector v = {0};
    auto i = begin(v) + v.size(); // 1. narrowing
  }

  {
    std::vector v = {0};
    auto i = 0;
    i = v.size(); // 2. narrowing
  }

  {
    std::vector v = {0};
    if (auto i = 0; i == v.size()) { // 3. ok
      ;
    }
  }
```

in above c++ code:

1. why ` begin(v) + v.size() ` causes narrowing static check?
  because iterator arithmetic requires an operand of long or int,
  while v.size() is unsigned long which is larger than long or int, right?

2. why `i=v.size()` causes narrowing check?
  because in assignment, the value at right if converted to the type of the value at left,
  v.size() is unsigned long and is larger one, the i on left is int, right?

3. why `i==v.size()` does not cause narrowing check?
  because operators like `==` promotes the smaller value to the type of the large value, right?

in c,c++, are the following correct?

K&R C 2.7:

- in assignment, value on right is converted to type of the value at left;
- in function call, actual arguments are converted to formal parameter type of the function;
- in other binary operators which take multiple operands of different types,
  like *, /, %, +, -, the narrower operand is promoted to the type of
  the wider operand without losing information.

  When an operator has operands of different types, they are converted
  to a common type according to a small number of rules. In general,
  the only automatic conversions are those that convert a "narrower" operand
  into a "wider" one without losing information.

  Implicit arithmetic conversions work .much as expected.
  In general, if an operator like + or * that takes two operands (a
  binary operator) has operands of different types, the "lower" type is
  promoted to the "higher" type before the operation proceeds.
  The result is of the higher type.

- all integral smaller than int are converted to int before arithmetic operation takes place;

K&R C, A.6.1 Integral Promotion:

- A character, a short integer, ..is converted to int;

  (then long int, long long int, they are all int)

K&R C 4.1:

- in function return, return value is converted to return type of the function;


c-faq, 3.11, https://c-faq.com/expr/intoverflow1.html

arithmetic operation is performed under using int arithmetic,
explicitly convert individual operand larger than int to larger type.

  long int c = (long int)(a * b); // error, conversion, it happens too late
  long int c = (long int)a * b; // ok, explicit type conversion on operand


int main() {
  int intMax = INT_MAX;          // 2147483647, macOS 64bit;
  int sqrtMax = sqrt(INT_MAX);   // 46340;
  int powSqrt = pow(sqrtMax, 2); // 2147395600;
  long int longMax = LONG_MAX;   // 9223372036854775807;

  // the point of c-faq 3.11 is:
  // operands a and b are both valid int,
  // but expression a * b may exceed int,
  // explicitly convert a operand to higer long int,
  // and the result expression is the higher type.
  a = sqrt(INT_MAX), b = sqrt(INT_MAX);
  c = a * b * 10;
  c2 = (long)a * b * 10;                // ok;
  std::cout << c << ", " << c2 << "\n"; // -880480, 21473956000;

  // K&R C, 2.3:
  // an integer too big to fit into an int will also be taken as a long.
  // integer literal may not need explicit conversion.
  c = 463400 * 46340;                   // 46340 * 10 * 46340;
  c2 = (long)463400 * 46340;            // 46340 * 10 * 46340;
  std::cout << c << ", " << c2 << "\n"; // -880480, 21473956000;

  double f = 10 / 3;          // 3;
  double f2 = (double)10 / 3; // ok, 3.33;

  return 0;
}


---


// c++
// typeid(var).name()
// typeid(int).name()

#include <cxxabi.h>
#include <typeinfo>

template <typename T> std::string demangle(const T &t) {
  int status = 0;
  auto name = typeid(t).name();
  std::unique_ptr<char, void (*)(void *)> res(
      abi::__cxa_demangle(name, nullptr, nullptr, &status), std::free);
  return (status == 0) ? res.get() : name;
}

#define TYPENAME(t) (std::string(#t) + ": " + typeid(t).name())

int main2() {
  std::cout << TYPENAME(void) << ";\n";
  std::cout << TYPENAME(char) << ", \t" << TYPENAME(unsigned char) << ";\n";
  std::cout << TYPENAME(short) << ", \t" << TYPENAME(unsigned short) << ";\n";
  std::cout << TYPENAME(int) << ", \t" << TYPENAME(unsigned int) << ";\n";
  std::cout << TYPENAME(long) << ", \t" << TYPENAME(unsigned long) << ";\n";
  std::cout << TYPENAME(long long) << ", \t" << TYPENAME(unsigned long long) << ";\n";
  std::cout << TYPENAME(float) << ", \t" << TYPENAME(double) << ", \t" << TYPENAME(long double) << ";\n";
  std::cout << TYPENAME(char *) << ", \t" << TYPENAME(char[]) << ";\n";

  return 0;
}


// void: v;
// char: c,        unsigned char: h;
// short: s,       unsigned short: t;
// int: i,         unsigned int: j;
// long: l,        unsigned long: m;
// long long: x,   unsigned long long: y;
// float: f,       double: d,      long double: e;
// char *: Pc,     char[]: A_c;


---

