<html>

<head>
  <style>
    /* https://developer.mozilla.org/en-US/docs/Web/CSS/color-scheme */
    :root {
      color-scheme: light dark
    }
  </style>
</head>

<body>

  <textarea disabled style="
    border: none;
    font-family: monospace;
    font-size: inherit;
    height: 100%;
    overflow-wrap: break-word;
    resize: none;
    width: 100%;">

c,c++ notes

// c,c++ source code file:
// the source file translation unit is composed of declarations.
// 1. top level file scope can only have declarations:
//    function declaration, variable declaration, type declaration, etc.
// 2. statements can only occur inside a function.

source file:
declarations:
type declaration,
variable declaration, // global
function declaration,

function:
variable declaration, // local
statements:
expressions statement,
control statement,
assignment statement,


---


# Minimal Makefile

# build dynamic library with -fPIC -shared
CFLAGS   = -g # -O3 -fPIC # CXXFLAGS for .cpp
CPPFLAGS = -MMD -MP # -I../foo -DNDEBUG
LDFLAGS  = # -L../foo -shared
LDLIBS   = # -lfoo
#CC      = $(CXX) # link with CXX for .cpp

# target name is basename of one of the source files
main : $(patsubst %.c,%.o,$(wildcard *.c)) # .cpp
-include *.d
clean : ; -rm -fr *.o *.d main
.PHONY : clean


---


K&R C 2.7:

- in assignment, value on right is converted to type of the value at left;
- in function call, actual arguments are converted to formal parameter type of the function;
- in other binary operators which take multiple operands of different types,
  like *, /, %, +, -, the narrower operand is promoted to the type of
  the wider operand without losing information.

  When an operator has operands of different types, they are converted
  to a common type according to a small number of rules. In general,
  the only automatic conversions are those that convert a "narrower" operand
  into a "wider" one without losing information.

  Implicit arithmetic conversions work .much as expected.
  In general, if an operator like + or * that takes two operands (a
  binary operator) has operands of different types, the "lower" type is
  promoted to the "higher" type before the operation proceeds.
  The result is of the higher type.


---


// c++ primer 5th, 4.11.1:
The integral promotions convert the small integral types to a larger integral type.
The types bool, char, signed char, unsigned char, short, and unsigned short are
promoted to int if all possible values of that type fit in an int.


---


// K&R C 2nd,
// 1.2:
// integer division (operation), floating-point operation,
// integer division would truncate it to zero.

// 2.7:
// explicit type conversions can be forced ("coerced") in any expres- sion,
// with a l!nary operator called a cast.

double f1 = 10/3; // warning
double f2 = 10.0/3; // ok
double f3 = (double)10/3; // ok


---


// integer overflow:

https://c-faq.com/expr/intoverflow1.html, 3.14,

int a = INT_MAX;
int b = INT_MAX;

long int c1 = (long int)a * b;   // ok, convert one operand first;
long int c2 = (long int)(a * b); // error;
long int c3 = a * b;             // error;


// K&R C, 2.3:
// an integer too big to fit into an int will also be taken as a long.
// integer literal may not need explicit conversion.

auto c1 = INT_MAX + 1;             // long;
auto c2 = (long)INT_MAX + INT_MAX; // c2 value is int without conversion;
auto c3 = INT_MAX + INT_MAX;       // error;


---


// array address bound check, dangling pointer, etc.:

https://github.com/google/sanitizers/wiki/AddressSanitizer ,

Heap buffer overflow,
Stack buffer overflow,
Global buffer overflow,

Use after free (dangling pointer dereference),
Use after return,
Use after scope,

Memory leaks,


---


https://c-faq.com/expr/confused.html, 3.11,

If an object (as defined above) appears more than once in an expression,
and is the object modified in the expression, make sure that all
appearances of the object which fetch its value participate in the
computation of the new value which is stored.
This rule allows the expression:

i = i + 1 ; // only fetch its value on the right side, then assign it.
// i = i++; // error, increment its value on the right side, then assign it.

because although the object i appears twice and is modified,
the appearance (on the right-hand side) which fetches i's old value
is used to compute i's new value.


---


https://c-faq.com/expr/evalorder1.html, 3.1:

The subexpression i++ causes a side effect--it modifies i's value--which leads
to undefined behavior since i is also referenced elsewhere in the same
expression. There is no way of knowing whether the reference will happen before
or after the side effect--in fact, neither obvious interpretation might hold;

a[i] = i++; // error
i + (i = 1); // error?


---


# CXXFLAGS += -fsanitize=address -fsanitize=undefined
# LDFLAGS  += -fsanitize=address -fsanitize=undefined

// StackOutOfBounds
int main(int argc, char **argv) {
  int stack_array[100];
  stack_array[1] = 0;
  return stack_array[argc + 100];  // BOOM
}

// UseAfterFree
int main(int argc, char **argv) {
  int *array = new int[100];
  delete [] array;
  return array[argc];  // BOOM
}


/*


https://github.com/google/sanitizers?tab=readme-ov-file ,

AddressSanitizer (detects addressability issues) and LeakSanitizer (detects memory leaks),
ThreadSanitizer (detects data races and deadlocks) for C++ and Go,
MemorySanitizer (detects use of uninitialized memory),

HWASAN, or Hardware-assisted AddressSanitizer, a newer variant of AddressSanitizer that consumes much less memory,
UBSan, or UndefinedBehaviorSanitizer,

*/


---


CppCon 2014: "Sanitize your C++ code", Kostya Serebryany,
CppCon 2015: "Beyond Sanitizers", by Kostya Serebr,
https://www.usenix.org/sites/default/files/conference/protected-files/enigma_slides_serebryany.pdf ,

1. Sanitizer:
address,
leak,
uninitialized memory,
undefined behavior,
thread;

flags: -fsanitize={address, leak, memory, undefined, thread} ;

both compiling and linking should include the flag:
    CXXFLAGS += -sanitize=address
    LDFLAGS += -sanitize=address


2. Coverage tests with llvm libfuzzer:
flags: -fsanitizer=coverage ;


3. Harden your code:
3.1  Threat #1: Buffer-overflow/use-after-free
overwrites a function pointer (or vptr)
by an attacker-controlled value:

Solution:  Control Flow Integrity (CFI)

flags: -flto -fsanitize=cfi

3.2. Threat #2: Stack-buffer-overflow
overwrites return address by an attacker-
controlled value:

Solution: safestack

flags: -sanitize=safe-stack ;


---


// rule of zero
struct S {
  std::string name;
  int num;
  // S(const std::string name, int num) : name(name), num(num) {}
};

int main() {
  std::vector<S> v;

  v.emplace_back("abc", 123); // newer gcc 14 -std=23 on fedora 40
  v.emplace_back(S{"abc", 123});
  v.push_back({"abc", 123});

  return 0;
}


Aggregates in C++17 are defined as classes (including structs) that:
Have no user-declared constructors.
Have no private or protected non-static data members.
Have no base classes.
Have no virtual member functions.

the presence of the std::string member disqualifies S from being
an aggregate under C++17 rules.
When you try to use emplace_back("abc", 123) in C++17,
the compiler looks for a matching constructor in S that takes two parameters,
but since you haven't explicitly defined such a constructor,
it results in a compilation error.

C++20 and Later

In C++20, the rules for aggregate initialization were relaxed.
a class contains members with default constructors (like std::string),
it can still be considered an aggregate, provided that the other conditions
(no private members, no user-declared constructors, etc.) are met.

This means that in C++20, S can be aggregate-initialized directly
using the two provided arguments ("abc" and 123) for its members name and num.
The compiler can now generate the appropriate initialization without requiring
an explicit constructor.
So in C++20 and later, this code works:

v.emplace_back("abc", 123);

The compiler can treat this as aggregate initialization,
directly constructing an S object by passing the arguments to
the name (std::string) and num (int) members.


---


// c++ primer 5th, 3.2.1:
When we initialize a variable using =,
we are asking the compiler to copy initialize the object;
when we omit the =, we use direct initialization;

creating a (temporary) object to copy:

  string s8 = string(10,'c'); // copy initialization; s8 is cccccccccc ;


// c++ primer 5th, 7.5.5:
We can initialize the data members of an aggregate class
by providing a braced list of member initializers:

  struct Data {
    int ival;
    string s;
  };

  // val1.ival=0;val1.s=string("Anna")
  Data val1 = { 0, "Anna" };


// 11.1 Using an Associative Container:
A map is a collection of keyâ€“value pairs.
The map type is often referred to as an associative array.
It uses each word to subscript word_count.
If word is not already in the map,
the subscript operator creates a new element whose key is word
and whose value is 0.


// https://en.cppreference.com/w/cpp/container/map/operator_at.html :
Inserts value_type(key, T()) if the key does not exist.


// 11.3.4 Subscripting a map:
the map subscript takes an index (that is, a key),
if the key is not already present,
a new element is created and inserted into the map for that key.
The associated value is value initialized.


---


// c,c++ initialization

// =  for initialization (and assignment):
// basic types: char, int, float, double, pointers.
int n = 123;

// {}  for initialization:
// array, structure, c++ initializer_list,
int a1[10] = {0};
int a2[] = "hello"; //a2 with nul,
struct point {int x,y} pt = {10, 20};
vector<string> articles = {"a", "an", "the"};

// ()  for initialization:
// c++ class constructor.
string s1("hello"); // library string without nul.
string s2 = "hello"; //string::c_str() with nul.
string s3(10, 'c');
string s4 = string(10, 'c');

// if struct has more members than initializers,
// or array has more elements than initializers,
// the rest without initializers will be zero.
char arr1[10] = {'a','b','c'};
char arr2[10] = "abc";
struct T{ int a; int b; int c; } t = {1};


---


// string and array

/* const*/ char *ptr = "hello"; // pointer to const string literal
// *ptr = 'H';   // error, immutable,
// ptr[0] = 'H'; // error, immutable,

char arr[] = "hello"; // assign string literal to built-in array.
*arr = 'H';   // ok
arr[0] = 'H'; // ok


---


https://c-faq.com/expr/intoverflow1.html, 3.14,

int a = INT_MAX;
int b = INT_MAX;
long int c = a * b; // error
long int c = (long int)(a * b); // error, conversion, it happens too late

Under C's integral promotion rules, the multiplication is carried out
using int arithmetic, and the result may overflow or be truncated before
being promoted and assigned to the long int left-hand side.
Use an explicit cast on at least one of the operands to force long arithmetic:

int a = INT_MAX;
int b = INT_MAX; // or, long b = INT_MAX;
long int c = (long int)a * b; // ok, explicit type conversion on operand
long int d = ((long int)a) * b; // ok, explicit type conversion on operand
long int e = (1L * a) * b;


---


https://www.open-std.org/jtc1/sc22/wg21/docs/standards ,
https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/n4950.pdf ,

sec 6.8.2 :

Note 2 : Unsigned arithmetic does not overflow.
Overflow for signed arithmetic yields undefined behavior (7.1).

// or, underflow and overflow is well defined in unsigned integers

auto x = UINT_MAX; // 4294967295
auto x2 = 5 - UINT_MAX; // 6
auto x3 = 5 - (long)UINT_MAX; // -4294967290

// leetcode 58. Length of Last Word
// https://leetcode.cn/problems/length-of-last-word/description ,

#include <iostream>
#include <vector>
#include <string>
using namespace std;

int lengthOfLastWord(string s) {
  auto a = s.find_last_not_of(' ');
  auto b = s.find_last_of(' ', a);
  return a - b;
}

int main() {
  std::cout << lengthOfLastWord("hello") << "\n"; // 5 - string::npos == 6 // ?
  // std::cout << lengthOfLastWord("hello guys") << "\n";
  // std::cout << lengthOfLastWord(" hello c++ ") << "\n";
  return 0;
}


---


"                                                                   "
"  K&R C 2nd, A4.2:                                                 "
"  obey the laws of arithmetic modulo 2^n                           "
"  arithmetic on unsigned quantities can never overflow             "
"                                                                   "
"  unsigned integers                                                "
"                                                                   "
"          M  M                                                     "
"          A  I                                                     "
"          X, N,                                                    "
"             0                                                     "
"          *  *   1                                                 "
"       *        *                                                  "
"      *          * 2                                               "
"      *          *                                                 "
"       *        *                                                  "
"          *  *                                                     "
"                                                                   "
"  ---------------------------------------------------------------  "
"                                                                   "
"  K&R C 2nd, A6.2:                                                 "
"  When any integer is converted to a signed type,                  "
"  the value is unchanged if it can be represented in the new type  "
"  and is implementation-defined otherwise.                         "
"                                                                   "
"  signed int                                                       "
"                                                                   "
"  MIN, ..  -2,-1, 0, 1, 2, ..  MAX,                                "
"   *  *  *  *  *  *  *  *  *  *  *                                 "
"                                                                   "


---


https://c-faq.com/misc/intovf.html, 20.6b,
https://c-faq.com/misc/sd26.html,

How can I ensure that integer arithmetic doesn't overflow?

The usual approach is to test the operands against the limits in the
header file <limits.h> before doing the operation. For example,
here is a ``careful'' addition function:

int chkadd(int a, int b) {
  if(INT_MAX - b < a) {
    fputs("int overflow\n", stderr);
    return INT_MAX;
  }
  return a + b;
}

Here is a complete set of three functions for ``careful''
addition, subtraction, and multiplication.
(Note: these functions are still not perfect, and may fail if invoked on
various edge cases, such as the smallest negative integer, INT_MIN.)

#include <stdio.h>
#include <limits.h>

int chkadd(int a, int b) {
  if(b < 0)
    return chksub(a, -b);
  if(INT_MAX - b < a) {
    fputs("int overflow\n", stderr);
    return INT_MAX;
  }
  return a + b;
}

int chksub(int a, int b) {
  if(b < 0)
    return chkadd(a, -b);
  if(INT_MIN + b > a) {
    fputs("int underflow\n", stderr);
    return INT_MIN;
  }
  return a - b;
}

int chkmul(int a, int b) {
  int sign = 1;
  if(a == 0 || b == 0) return 0;
  if(a < 0) { a = -a; sign = -sign; }
  if(b < 0) { b = -b; sign = -sign; }
  if(INT_MAX / b < a) {
    fputs("int overflow\n", stderr);
    return (sign > 0) ? INT_MAX : INT_MIN;
  }
  return sign * a * b;
}


---


// https://en.cppreference.com/w/cpp/language/implicit_conversion ,

prvalues of small integral types (such as char) may be converted to
prvalues of larger integral types (such as int).

In particular, arithmetic operators do not accept types smaller
than int as arguments, and integral promotions are automatically applied
after lvalue-to-rvalue conversion, if applicable.


// K&R C 2nd:

2.3 Constants:
An integer constant like 1234 is an int.
A long constant is written with a terminal 1 (ell) or L, as in 123456789L;
an integer too big to fit into an int will also be taken as a long.
Unsigned constants are written with a terminal u or U,
and the suffix ul or UL indicates unsigned long.

2.7 Type Conversions:
Otherwise, convert char and short to int.

A.6.1 Integral Promotion:
A character, a short integer, ..is converted to int;


---


// temporary

#include <iostream>

int main() {
  char c1 = toupper(std::string_view("abc")[0]);    //ok
  char c2 = toupper(std::string("abc").c_str()[0]); //ok

  // temporary of an temporary
  const char *a = (std::string("abc")).c_str(); //error

  // https://en.cppreference.com/w/cpp/language/lifetime ,
  // lifetime of a temporary object may be extended by binding to
  // a const lvalue reference
  const int &r = 10; // ok,
  int &r2 = 10; // error,
  const std::string &b = std::string("abc");    //ok
  const char *c3 = b.c_str();                   //ok
  std::cout << c3 << "\n";

  //or, use an intermediate temporary variable
  std::string tmp = std::string("abc");
  const char *p = tmp.c_str();

}


---


#include <iostream>
#include <vector>

int main() {
  // std::vector<int *> v1; // better to use std::shared_ptr instead of `int *`,
  std::vector<const int *> v1;
  std::vector<int> v2 = {1, 2, 3};

  // 1. error: {1,2,3} is temporary, and i is a local copy,
  // for (auto i : {1, 2, 3}) {

  // 2. error: const lvalue reference extends teomporary only within for loop,
  // for (const auto &i : {1, 2, 3}) {

  // 3. error: i is a local copy of element in v2,
  // for (auto i : v2) {

  // 4. ok: i refers to v2,
  for (auto &i : v2) {
    v1.push_back(&i);
  }

  for (auto i : v1) {
    std::cout << *i << "\n";
  }

  return 0;
}


---


// struct literal, temporary,

struct T{};
(struct T){} = (struct T){};

https://en.cppreference.com/w/c/language/value_category ,
compound literals, which look similar, are lvalues

https://en.cppreference.com/w/c/language/compound_literal ,
The value category of a compound literal is lvalue (its address can be taken)


---


//https://en.cppreference.com/w/cpp/language/expressions#Literals ,
//Literals are the tokens of a C++ program that represent constant values
//embedded in the source code.

//C: temporary struct is struct literal. it is constant.
//C: can not change member data of temporary.
//C++: temporary is object constructed by constructor.
//C++: can not change member data of temporary.
//C++: can not invoke builtin operator & on temporary.
//C++: member functions and operators can be invoked on temporary objects.

typedef struct T {
  int num;
} T;

T f1() {
  return (T){.num = 123,};
}

//lvalue reference requires const if argument is temporary
void f2_accept_temp(const T &t) {
}

//rvalue reference
void f3(T &&t) {
}

int main() {
  //c: return value is struct literal
  //f1() = f1(); //error: expression is not assignable
  //f1().num++; //error: expression is not assignable
  //T *p = &f1(); //error: cannot take the address of an rvalue of type 'T' (aka 'struct T')

  //c++: return value is class/struct object
  f1() = f1(); //ok, invoke member operator= of the class
  //f1().num++; //error: expression is not assignable
  //T *p = &f1(); //error: taking the address of a temporary object of type 'T' [-Waddress-of-temporary]

  int n = f1().num;
  T t = f1();

  f2_accept_temp((T){});
  f3((T){});

  return 0;
}


---


https://en.cppreference.com/w/c/language/lifetime ,

Temporary lifetime
Struct and union objects with array members (either direct or members of
nested struct/union members) that are designated by non-lvalue expressions,
have temporary lifetime. Temporary lifetime begins when the expression
that refers to such object is evaluated and ends at
the next sequence point (until C11)
when the containing full expression or full declarator ends (since C11).

Any attempt to modify an object with temporary lifetime results in undefined behavior.

struct T { double a[4]; };
struct T f(void) { return (struct T){3.15}; }
double g1(double* x) { return *x; }
void g2(double* x) { *x = 1.0; }

int main(void) {
  double d = g1(f().a); // C99: UB access to a[0] in g1 whose lifetime ended
                        //      at the sequence point at the start of g1
                        // C11: OK, d is 3.15
  g2(f().a); // C99: UB modification of a[0] whose lifetime ended at the sequence point
             // C11: UB attempt to modify a temporary object
}


---


// Sequence point occurs:

$ 7.12.1, C A reference manual, 5th
- at the end of a full expression--that is,
  an initializer, an expression statement, the expression in a return
  statement, and the control expressions in a conditional, iterative,
  or switch statement (including each expression in a for statement)
- after the first operand of a &&, ||, ?:, or comma operator
- after the evaluation of the arguments and function expression in a
  function call


---


https://c-faq.com/expr/seqpoints.html, 3.8,

Between the previous and next sequence point an object shall have its
stored value modified at most once by the evaluation of an expression.
Furthermore, the prior value shall be accessed only to determine the
value to be stored.

- full expression or expression statement has sequence point at its end,
  subexpresion has sequence point only there is  &&  ||  :?  ,  in it.

- a variable can be modified only once within one single sequence point.

- expressions like i = i + 1 which use and modify i but only modify it later
when it's reasonably easy to ensure that the final store of the final value
(into i, in this case) doesn't interfere with the earlier accesses.

  i = i++;    // error, increment its value on the right side, then assign it.
  i++ * i++;  // error
  i = i + 1;  // ok
  i = i + 1;  // ok
  i++ && i++; // ok


---


https://c-faq.com/expr/confused.html, 3.11,

If an object (as defined above) appears more than once in an expression,
and is the object modified in the expression, make sure that all
appearances of the object which fetch its value participate in the
computation of the new value which is stored.
This rule allows the expression:

i = i + 1 ; // only fetch its value on the right side, then assign it.
// i = i++; // error, increment its value on the right side, then assign it.

because although the object i appears twice and is modified,
the appearance (on the right-hand side) which fetches i's old value
is used to compute i's new value.

i + (i = 1); // error ?


---


// 1. function argument pass by value
// will not change the argument passed by caller
void f1(int x){
  x++;
}

// 2. function argument pass by const reference
// (1) will not change the actual argument passed by caller
void f2(const int &x){
  // (2) can not change formal parameter declared as const too
  // x++; // error: assign to const

  auto y = x; // make a copy
  y++; // ok
}

// 3. function argument pass by reference
// will change the actual argument passed by caller
void f3(int &x){
  x++;
}

int main(){
  int num = 10;
  f1(num); // num is not changed
  f2(num); // num is not changed
  f3(num); // num is changed
  return 0;
}


---


https://en.cppreference.com/w/cpp/language/rule_of_three ,

// rule of three / five / zero

class rule_of_five {
  char* cstring; // raw pointer used as a handle to a
                 // dynamically-allocated memory block
public:
  explicit rule_of_five(const char* s = "") : cstring(nullptr) {
    if (s) {
      std::size_t n = std::strlen(s) + 1;
      cstring = new char[n];      // allocate
      std::memcpy(cstring, s, n); // populate
    }
  }

  ~rule_of_five() {
    delete[] cstring; // deallocate
  }

  rule_of_five(const rule_of_five& other) // copy constructor
    : rule_of_five(other.cstring) {}

  rule_of_five(rule_of_five&& other) noexcept // move constructor
    : cstring(std::exchange(other.cstring, nullptr)) {}

  rule_of_five& operator=(const rule_of_five& other) { // copy assignment
    return *this = rule_of_five(other);
  }

  rule_of_five& operator=(rule_of_five&& other) noexcept { // move assignment
    std::swap(cstring, other.cstring);
    return *this;
  }

// alternatively, replace both assignment operators with
//  rule_of_five& operator=(rule_of_five other) noexcept {
//    std::swap(cstring, other.cstring);
//    return *this;
//  }
};


/*

notes:

1. delegating constructor:

  rule_of_five(rule_of_five&& other) noexcept // move constructor
    : cstring(std::exchange(other.cstring, nullptr)) {}

2. inside the copy assignment,
   the move assignment is called on the temporary object:

  rule_of_five& operator=(const rule_of_five& other) { // copy assignment
    return *this = rule_of_five(other);
  }

3. copy and swap:
  pass arguments by value to function,
  for the single value parameter, copy or move constructor is called.
  it will call copy or move constructor instead of assignment operator.
  assignment operator is for assigning a value to an existing variable.
  constructor is for creating a new parameter object.

  c++ primer 5th, 13.3: copy and swap.
  c++ primer 5th, 13.1.1: parameters that have a nonreference type are copy initialized.

  rule_of_five& operator=(rule_of_five other);

  rule_of_five t1, t2;
  t2 = t1;
  t2 = std::move(t1);

*/


---


// initialization:
// create new object
// the value on right hand side is initializer
// invoke copy or move constructors
Foo newObj = old;
Foo newObj(old);
Foo newObj{old};

// assignment:
// assign value on right to left
// invoke copy or move assignment operators
old2 = old2;


---


// c++11 rvalue reference, move operation semantics,
// bind rvalue reference to element in container,
// move element out of container,

#include <iostream>
#include <vector>
#include <utility>

void f(std::string &&s){
  std::string t = std::move(s); // move
}

void f(std::string &s){ // ok too
  std::string t = std::move(s); // move
}

int main() {
  std::vector<std::string> v1 = {"hello", "world", "abc"};
  auto elem = std::move(v1[0]); // 1. move
  f(std::move(v1[1])); // 2. move
  f(v1[2]); // 3. move

  //---

  std::vector<std::string> v2 = {"hello", "world", "abc"};
  std::vector<std::string> v3;

  // for (auto &e : v2) { // ok
  for (auto &&e : v2) { // ok
    v3.emplace_back(std::move(e)); // 4. move
  }

  return 0;
}


//---


// Converting from Iterator to Reverse Iterator.
#include <iostream>
#include <iterator>
#include <vector>

int main() {
  std::vector<int> vec = {1, 2, 3, 4, 5};
  auto it = vec.begin() + 2;
  std::cout << *it << "\n"; // 3
  // std::reverse_iterator<decltype(it)> rev_it(it); // ok
  auto rev_it = std::make_reverse_iterator(it); // ok
  std::cout << *rev_it << "\n";                 // 2
  rev_it--;                                     // ok
  std::cout << *rev_it << "\n";                 // 3, same element

  return 0;
}

// Converting from Reverse Iterator to Iterator.
// A reverse iterator points to the element that precedes the one it actually
// represents. It is conceptually working backwards. Its .base() method will
// return an iterator that points to the next element in the underlying
// container (which means the original element before the reverse iteration).

int main2() {
  std::vector<int> vec = {1, 2, 3, 4, 5};
  auto rev_it = vec.rbegin() + 2;
  std::cout << *rev_it << "\n"; // 3
  auto it = rev_it.base();
  std::cout << *it << "\n"; // 4

  it--;                     // ok
  std::cout << *it << "\n"; // 3, same element

  return 0;
}


//---


// reserve:

// std::string str;
// str.reserve(100); // capacity == 100; size == 0;
// std::vector<int> vec;
// vec.reserve(100); // capacity == 100; size == 0;


// initialize object with size:

// if you specify a size, the allocation will typically occur once,
// similar to calling reserve(), but it also initializes all elements.
// reserve allocate storage but do not initialize elements.

// std::string str(100, ' '); // size == 100
// std::vector<int> v(100);   // size == 100


//---


#include <iostream>
#include <string>
#include <vector>

int main() {

  {
    // 1. std::string::find(),
    // search for substring in specified range in a larger string,

    std::string haystack = "abaCabaCabaCaba";
    std::string needle = "aba";

    // std::string haystack = "abababababababa";
    // std::string needle = "aba";

    const size_t first = 1; // 0;                              // 1;
    const size_t last = 11; // end(haystack) - begin(haystack); // 11;

    std::cout << __LINE__ << ": ";
    for (size_t i = first, j = last, k = std::string::npos;
         (k = haystack.find(needle, i)) < j; i = k + size(needle)) {
      std::cout << k << ", ";
    }
    std::cout << "\n";
  }

  {
    // 2. string, std::search(),
    // search for substring in specified range in a larger string,

    std::string haystack = "abaCabaCabaCaba";
    std::string needle = "aba";

    // std::string haystack = "abababababababa";
    // std::string needle = "aba";

    const size_t first = 1; // 0;                              // 1;
    const size_t last = 11; // end(haystack) - begin(haystack); // 11;

    std::cout << __LINE__ << ": ";
    for (auto i = begin(haystack) + first, j = begin(haystack) + last,
              k = begin(haystack);
         (k = search(i, j, begin(needle), end(needle))) != j;
         i = end(needle) - begin(needle) + k) {
      std::cout << k - begin(haystack) << ", ";
    }
    std::cout << "\n";
  }

  {
    // 3. sequence, std::search(),
    // search for sub sequence in specified range in a larger sequence,

    // "abaCabaCabaCaba"
    std::vector haystack = {'a', 'b', 'a', 'C', 'a', 'b', 'a', 'C',
                            'a', 'b', 'a', 'C', 'a', 'b', 'a'};
    // "aba";
    std::vector needle = {'a', 'b', 'a'};

    // std::string haystack = "abababababababa";
    // std::string needle = "aba";

    const size_t first = 1; // 0;                              // 1;
    const size_t last = 11; // end(haystack) - begin(haystack); // 11;

    std::cout << __LINE__ << ": ";
    for (auto i = begin(haystack) + first, j = begin(haystack) + last,
              k = begin(haystack);
         (k = search(i, j, begin(needle), end(needle))) != j;
         i = end(needle) - begin(needle) + k) {
      std::cout << k - begin(haystack) << ", ";
    }
    std::cout << "\n";
  }

  {
    // 4. single value, std::find(),
    // search for single value or by predicate

    // "abaCabaCabaCaba"
    std::vector haystack = {'a', 'b', 'a', 'C', 'a', 'b', 'a', 'C',
                            'a', 'b', 'a', 'C', 'a', 'b', 'a'};
    char needle = 'C';

    // std::string haystack = "abababababababa";
    // std::string needle = "aba";

    const size_t first = 1; // 0;                              // 1;
    const size_t last = 11; // end(haystack) - begin(haystack); // 11;

    std::cout << __LINE__ << ": ";
    for (auto i = begin(haystack) + first, j = begin(haystack) + last,
              k = begin(haystack);
         (k = find(i, j, needle)) != j; i = k + 1) {
      std::cout << k - begin(haystack) << ", ";
    }
    std::cout << "\n";
  }

  return 0;
}


//---


// sort, search, find, algorithms

- string:
string::find(substring, pos);
string::rfind(substring, pos);
string::find_first_of(one_char_of_str, pos);
string::find_last_of(one_char_of_str, pos);

std::find(single_element);

- binary search:

std::qsort();
std::sort();

std::bsearch();
std::binary_search();
std::lower_bound(); // on sorted sequence;
std::upper_bound(); // on sorted sequence;
std::partition_point(); // on sorted or partitioned sequence;

- subsequence:
std::search(first, last, sub_first, sub_last);


//---


binary search, lower_bound, upper_bound, partition_point.
input sequence needs to be already in order and sorted by std::sort().

// lower:
lower_bound(begin(haystack), end(haystack), needle);
partition_point(begin(haystack), end(haystack), [&needle](auto &x){x < needle});

// upper:
upper_bound(begin(haystack), end(haystack), needle);
partition_point(begin(haystack), end(haystack), [&needle](auto &x){x <= needle});

equal_range(begin(haystack), end(haystack), needle);


---


#include <algorithm>
#include <iostream>
#include <string>
#include <tuple>
#include <vector>

struct S {
  std::string name;
  int num;
};

int main() {
  std::vector<S> haystack = {
      {"bbb", 20}, {"ccc", 30}, {"ddd", 40}, {"ccc", 30}, {"ccc", 30},
  };
  S needle = {"ccc", 30}; // "aaa", "zzz"

  std::sort(begin(haystack), end(haystack),
            [](const auto &a, const auto &b) -> bool {
              return std::tuple{a.name, a.num} < std::tuple{b.name, b.num};
            });

  auto lower = std::partition_point(
      begin(haystack), end(haystack), [&needle](const S &elem) -> bool {
        // use < for lower bound;
        return std::tuple{elem.name, elem.num} <
               std::tuple{needle.name, needle.num};
      });

  auto upper = std::partition_point(
      begin(haystack), end(haystack), [&needle](const S &elem) -> bool {
        // use <= for upper bound;
        return std::tuple{elem.name, elem.num} <=
               std::tuple{needle.name, needle.num};
      });

  if (lower == upper) {
    std::cout << "none\n";
  } else {
    std::cout << "lower: " << lower - begin(haystack) << ", "
              << "upper: " << upper - begin(haystack) << "\n";
  }

  return 0;
}


//---


// cppreference.com, html-book-20240610/reference/en/cpp/algorithm/search_n.html:

template<class Container, class Size, class T>
constexpr bool consecutive_values(const Container& c, Size count, const T& v) {
  return std::search_n(std::begin(c), std::end(c), count, v) != std::end(c);
}

int main() {
  constexpr char sequence[] = ".0_0.000.0_0.";

  static_assert(consecutive_values(sequence, 3, '0'));

  for (int n : {4, 3, 2})
    std::cout << std::boolalpha
            << "Has " << n << " consecutive zeros: "
            << consecutive_values(sequence, n, '0') << '\n';

  std::vector<std::complex<double>> nums{{4, 2}, {4, 2}, {1, 3}};
  #ifdef __cpp_lib_algorithm_default_value_type
    auto it = std::search_n(nums.cbegin(), nums.cend(), 2, {4, 2});
  #else
    auto it = std::search_n(nums.cbegin(), nums.cend(), 2, std::complex<double>{4, 2});
  #endif
  assert(it == nums.begin());
}

1. because the consecutive_values is constexpr so static_assert can be
used on the call to consecutive_values, because sequence is constexpr so
consecutive_values can be constexpr,

2. if the input sequence data is from user input at runtime,
then sequence can not be constexpr, and consecutive_values can not be constexpr,
and static_assert can not be used on the call to consecutive_values,


---


assert from the cassert will be ignored when NDEBUG is defined.
static_assert can not be ignored, and it works at compile time when writing the program.
static_assert evaluates expression at compile-time.

value qualified with keyword const does not meet the requirement of compile time evaluation.
value qualified with keyword constexpr, consteval do meet the requirement of compile time evaluation.


---


const:
Indicates that a variable's value cannot be modified after its initialization.
it means it is a read-only value.
it is not compile-time constant value;

constexpr:
When applied to variables,
it means the variable is constant and must be initialized with a constant expression.
When applied to functions,
it means that the function can be evaluated at compile time if given constant expressions as arguments.

consteval:
indicates that a function is a compile-time function and
must always produce a compile-time constant when called.

constinit:
Guarantees that a variable is initialized at compile time
but does not enforce that it is immutable.
It can be modified after initialization, unlike const.
unlike constexpr, it does not require the variable to be truly constant throughout its lifetime.


---


K&R C 2.7:

- in assignment, value on right is converted to type of the value at left;
- in function call, actual arguments are converted to formal parameter type of the function;
- in other binary operators which take multiple operands of different types,
  like *, /, %, +, -, the narrower operand is promoted to the type of
  the wider operand without losing information.

  When an operator has operands of different types, they are converted
  to a common type according to a small number of rules. In general,
  the only automatic conversions are those that convert a "narrower" operand
  into a "wider" one without losing information.

  Implicit arithmetic conversions work .much as expected.
  In general, if an operator like + or * that takes two operands (a
  binary operator) has operands of different types, the "lower" type is
  promoted to the "higher" type before the operation proceeds.
  The result is of the higher type.

- all integral smaller than int are converted to int before arithmetic operation takes place;

K&R C, A.6.1 Integral Promotion:

- A character, a short integer, ..is converted to int;

  (then long int, long long int, they are all int)

K&R C 4.1:

- in function return, return value is converted to return type of the function;


https://c-faq.com/expr/intoverflow1.html, 3.14,

arithmetic operation is performed under using int arithmetic,
explicitly convert individual operand larger than int to larger type.

  long int c = (long int)(a * b); // error, conversion, it happens too late
  long int c = (long int)a * b; // ok, explicit type conversion on operand


int main() {
  int intMax = INT_MAX;          // 2147483647, macOS 64bit;
  int sqrtMax = sqrt(INT_MAX);   // 46340;
  int powSqrt = pow(sqrtMax, 2); // 2147395600;
  long int longMax = LONG_MAX;   // 9223372036854775807;

  // operands a and b are both valid int,
  // but expression a * b may exceed int,
  // explicitly convert a operand to higer long int,
  // and the result expression is the higher type.
  a = sqrt(INT_MAX), b = sqrt(INT_MAX);
  c = a * b * 10;
  c2 = (long)a * b * 10;                // ok;
  std::cout << c << ", " << c2 << "\n"; // -880480, 21473956000;

  // K&R C, 2.3:
  // an integer too big to fit into an int will also be taken as a long.
  // integer literal may not need explicit conversion.
  c = 463400 * 46340;                   // 46340 * 10 * 46340;
  c2 = (long)463400 * 46340;            // 46340 * 10 * 46340;
  std::cout << c << ", " << c2 << "\n"; // -880480, 21473956000;

  double f = 10 / 3;          // 3;
  double f2 = (double)10 / 3; // ok, 3.33;

  return 0;
}


---


// c++
// typeid(var).name()
// typeid(int).name()

#include <cxxabi.h>
#include <typeinfo>

template <typename T> std::string demangle(const T &t) {
  int status = 0;
  auto name = typeid(t).name();
  std::unique_ptr<char, void (*)(void *)> res(
    abi::__cxa_demangle(name, nullptr, nullptr, &status), std::free);
  return (status == 0) ? res.get() : name;
}

#define TYPENAME(t) (std::string(#t) + ": " + typeid(t).name())

int main2() {
  std::cout << TYPENAME(void) << ";\n";
  std::cout << TYPENAME(char) << ", \t" << TYPENAME(unsigned char) << ";\n";
  std::cout << TYPENAME(short) << ", \t" << TYPENAME(unsigned short) << ";\n";
  std::cout << TYPENAME(int) << ", \t" << TYPENAME(unsigned int) << ";\n";
  std::cout << TYPENAME(long) << ", \t" << TYPENAME(unsigned long) << ";\n";
  std::cout << TYPENAME(long long) << ", \t" << TYPENAME(unsigned long long) << ";\n";
  std::cout << TYPENAME(float) << ", \t" << TYPENAME(double) << ", \t" << TYPENAME(long double) << ";\n";
  std::cout << TYPENAME(char *) << ", \t" << TYPENAME(char[]) << ";\n";

  return 0;
}


// void: v;
// char: c,        unsigned char: h;
// short: s,       unsigned short: t;
// int: i,         unsigned int: j;
// long: l,        unsigned long: m;
// long long: x,   unsigned long long: y;
// float: f,       double: d,      long double: e;
// char *: Pc,     char[]: A_c;


---


// bit operation manipulation

#include <iostream>
#include <string>

int main() {
  auto FLAG = 0b001;
  auto x = 0b1011;

  // 1. test or check a bit against FLAG
  auto b = (x & FLAG) == FLAG;
  std::cout << __LINE__ << ": " << b << "\n";
  x = 0b1010;
  b = (x & FLAG) == FLAG;
  std::cout << __LINE__ << ": " << b << "\n";

  // 2. set a bit in FLAG
  x = 0b1010;
  std::cout << __LINE__ << ": " << std::bitset<4>(x) << "\n";

  x |= FLAG;
  std::cout << __LINE__ << ": " << std::bitset<4>(x) << "\n";

  // 3. clear or unset a bit in FLAG
  x = 0b1011;
  x &= ~FLAG;
  std::cout << __LINE__ << ": " << std::bitset<4>(x) << "\n";

  return 0;
}


---


// leetcode 3,
// https://leetcode.cn/problems/longest-substring-without-repeating-characters/ ,

#include <algorithm>
#include <string>
#include <unordered_map>

size_t lengthOfLongestSubstring(const std::string &s) {
  long max = 0;
  for (auto i = begin(s), j = i; j != end(s); ++j) {
    if (auto k = std::find(i, j, *j); k != j) {
      i = k + 1;
    }
    max = std::max(max, j - i + 1);
  }
  return max;
}

size_t lengthOfLongestSubstring2(const std::string &s) {
  std::unordered_map<char, std::string::const_iterator> map;
  long max = 0;
  for (auto i = begin(s), j = i; j != end(s); ++j) {
    if (auto k = map.find(*j); k != end(map) && k->second >= i) {
      i = k->second + 1;
    }
    map[*j] = j;
    max = std::max(max, j - i + 1);
  }
  return max;
}

size_t lengthOfLongestSubstring3(const std::string &s) {
  if (empty(s)) {
    return 0;
  }
  auto first = begin(s), last = first;
  for (auto i = begin(s); i != end(s) - 1; ++i) {
    for (auto j = i + 1; j != end(s); ++j) {
      if (auto k = find(i, j, *j); k != j) {
        i = k;
        break;
      }
      if (j - i > last - first) {
        first = i;
        last = j;
      }
    }
  }
  return last - first + 1;
}

#include <iostream>

int main() {
  std::cout << lengthOfLongestSubstring("abcabcbb") << "\n"; // 3
  std::cout << lengthOfLongestSubstring("bbbbb") << "\n";    // 1
  std::cout << lengthOfLongestSubstring("pwwkew") << "\n";   // 3
  std::cout << lengthOfLongestSubstring("") << "\n";         // 0
  std::cout << lengthOfLongestSubstring(" ") << "\n";        // 1
  std::cout << lengthOfLongestSubstring("abc") << "\n";      // 3
  std::cout << lengthOfLongestSubstring("aab") << "\n";      // 2
  std::cout << lengthOfLongestSubstring("abba") << "\n";     // 2
}


---


#include <iostream>
#include <ranges>
#include <vector>

// in c++ ranges library, the pipeline operator works by taking the
// result of the expression on the left-hand side and passing it as the
// first argument to the function on the right-hand side.

// half open range [begin, end)
inline constexpr auto range(size_t begin, size_t end, size_t step = 1) {
  return std::views::iota(begin, end) | std::views::stride(step);
};

// work with pipeline operator
inline constexpr auto slice(size_t begin, size_t end, size_t step = 1) {
  return std::views::drop(begin) | std::views::take(end - begin) |
         std::views::stride(step);
};

// work with function call
template <std::ranges::range Range>
inline constexpr auto slice(Range &&range, size_t begin, size_t end,
                            size_t step = 1) {
  return std::views::drop(range, begin) | std::views::take(end - begin) |
         std::views::stride(step);
};

int main() {
  for (auto i : range(2, 9, 2)) {
    std::cout << i << " ";
  }
  std::cout << "\n";

  std::vector<int> v = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

  for (const auto &e : v | slice(2, 9, 2)) {
    std::cout << e << " ";
  }
  std::cout << "\n";

  for (const auto &e : slice(v, 2, 9, 2)) {
    std::cout << e << " ";
  }
  std::cout << "\n";
  return 0;
}


---


// print log with source location in c

#define LOG(fmt, ...) printf("%s:%d: " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)
// #define LOG(fmt, ...) printf(fmt "\n", ##__VA_ARGS__)
// #define LOG(fmt, ...) printf(fmt " ", ##__VA_ARGS__)
//
// work with:
//      LOG();
//      LOG("foo");
//      LOG("%s, %f, %d", "foo", 3.14, 10);

//---

// #define LOG(fmt, ...) printf(fmt, __VA_ARGS__)
//
// does not work with:
//      LOG();
//      LOG("foo");

//---

// #define LOG(...) printf(__VA_ARGS__)
// #define LOG(fmt, ...) printf(fmt, ##__VA_ARGS__)
//
// do not work with:
//      LOG();


---


// log with source location in c++

#include <iostream>
#include <sstream>
#include <format>
#include <source_location>

// 1. c++11, gcc-14.2
template <typename... Args>
void expand1(const char *file, int line, Args&&... args) {
  std::ostringstream oss;
  oss << file << ":" << line << ": ";
  ((oss << args << ' ') , ...);
  std::cout << oss.str() << "\n";
}
#define LOG1(...) expand1(__FILE__, __LINE__ __VA_OPT__(,) __VA_ARGS__)

// 2. c++20, gcc-14.2
template <typename... Args>
void expand2(const char *file, int line, Args&&... args) {
  auto msg = std::format("{}:{}: {}", file, line,
    (std::string{} + ... + std::format("{} ", args)));
  std::cout << msg << "\n";
}
#define LOG2(...) expand2(__FILE__, __LINE__ __VA_OPT__(,) __VA_ARGS__)

// 3. c++20, gcc-14.2
template <typename... Args>
void expand(std::source_location&& src, Args&&... args) {
  auto msg = std::format("{}:{}: {}", src.file_name(), src.line(),
    (std::string{} + ... + std::format("{} ", args)));
  std::cout << msg << "\n";
}
#define LOG(...) expand(std::source_location::current() __VA_OPT__(,) __VA_ARGS__)


int main() {
  LOG(3.14, "abc", 10, 'a');
  LOG(3.14e2, "abc", 10 + 20);
  LOG(3.14);
  LOG("abc");
  LOG(10);
  LOG('a');
  LOG("");
  LOG();
}


---


// https://en.cppreference.com/w/cpp/language/pack ,
// Pack (since C++11) / Pack expansion,

template<class... Ts>
void g(Ts... args)
{
  // parameter pack, with initializer list
  // auto dummy = { (std::cout << args << '\n', 0)... };


  // unary left fold
  // (... , (std::cout << args));
  // (... , (std::cout << args << '\n'));
  // int sum = (... + args); // addition: g(10 + 20);


  // unary right fold
  // ((std::cout << args) , ...);
  // ((std::cout << args << '\n') , ...);
  // int sum = (args + ...); // addition: g(10 + 20);


  // binary left fold
  // (std::cout << ... << args);
  // (std::cout << ... << ( std::cout << '\n', args )) << '\n';
  // int sum = (0 + ... + args); // addition: g(10 + 20);


  // binary right fold:
  // Some operators are more naturally suited
  // to one direction of folding over the other.
  // (args >> ... >> std::cout);  // Syntax error: `>>` is input, not output!
  // int sum = (args + ... + 0);  // addition: g(10 + 20);

}

int main() {
  g(1, 0.2, "a");
  g(10);
  g(3.14);
  g("b");

  // g(10+ 20); // for addition

}


---


// log with printf, va args,
if use __VA_ARGS__ without ## ,
use the first way to print empty content:

  1. LOG1("%s", ""); // print empty content, when __VA_ARGS__ is without ## ,
  2. LOG1(""); // no,
  3. LOG1(); // no,


// ##__VA_ARGS__ is used to handle cases where __VA_ARGS__ might be empty.
// It ensures that if there are no arguments passed after fmt,
// the comma before __VA_ARGS__ is removed during macro expansion.


// LOG1,

// ##__VA_ARGS__ , with double ## , it is gnu extension.

  LOG1("%s %d %f", "bbb", 10, 3.14);
  LOG1("%s", ""); // always with arguments, print empty string
  LOG1(""); // ok,
  LOG1(); // ok,

// $ date "+%Y-%m-%d %H:%M:%S %Z"
// 2024-09-24 07:41:59 CST
// $

#define LOG1(fmt, ...)                                                         \
  do {                                                                         \
    char buf[100];                                                             \
    time_t now = time(nullptr);                                                \
    strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S %Z", localtime(&now));       \
    fprintf(stdout, "%s  %s:%d]  " fmt "\n", buf, __FILE__, __LINE__,          \
            ##__VA_ARGS__);                                                    \
  } while (0)


// LOG2,

// __VA_ARGS__ , without ## , it is more portable.

  LOG2("%s %d %f", "bbb", 10, 3.14);
  LOG2("%s", ""); // always with arguments, print empty string
  // LOG2(""); // no,
  // LOG2(); // no,

// $ date "+%Y-%m-%d %H:%M:%S %Z"
// 2024-09-24 07:41:59 CST
// $

#define LOG2(fmt, ...)                                                         \
  do {                                                                         \
    char buf[100];                                                             \
    time_t now = time(nullptr);                                                \
    strftime(buf, sizeof(buf), "%Y-%m-%d %H:%M:%S %Z", localtime(&now));       \
    fprintf(stdout, "%s  %s:%d]  " fmt "\n", buf, __FILE__, __LINE__,          \
            __VA_ARGS__);                                                    \
  } while (0)


int main() {
  LOG1("%s, %f", "abc", 3.14);
  LOG1("%s", ""); // print empty string
  LOG1(""); // ok,
  LOG1(); // ok,

  LOG2("%s, %f", "abc", 3.14);
  LOG2("%s", ""); // always with arguments, print empty string
  // LOG2(""); // no,
  // LOG2(); // no, because no ## before __VA_ARGS__ in LOG2, but this is more portable

  return 0;
}


---


$ cat log.cpp

// boost log
// ../boost_1_86_0/libs/log/example/basic_usage/main.cpp ,
// ../boost_1_86_0/libs/log/example/rotating_file/main.cpp ,
// ../boost_1_86_0/libs/log/example/doc/tutorial_fmt_stream.cpp ,

// makefile:
// CPPFLAGS  = -MMD -MP -I../boost_1_86_0 -DBOOST_LOG_DYN_LINK
// LDFLAGS   = -L../boost_1_86_0/stage/lib
// LDLIBS    = -lboost_log -lboost_log_setup -lboost_chrono -lboost_filesystem
//              -lboost_thread -lboost_atomic

// environment variable:
// $ LD_LIBRARY_PATH=../boost_1_82_0/stage/lib  ./a.out

#include <boost/date_time/posix_time/posix_time.hpp>
#include <boost/date_time/posix_time/posix_time_types.hpp>
#include <boost/log/attributes.hpp>
#include <boost/log/attributes/named_scope.hpp>
#include <boost/log/attributes/timer.hpp>
#include <boost/log/common.hpp>
#include <boost/log/expressions.hpp>
#include <boost/log/sinks/sync_frontend.hpp>
#include <boost/log/sinks/text_file_backend.hpp>
#include <boost/log/sources/logger.hpp>
#include <boost/log/sources/record_ostream.hpp>
#include <boost/log/sources/severity_logger.hpp>
#include <boost/log/support/date_time.hpp>
#include <boost/log/trivial.hpp>
#include <boost/log/utility/setup/common_attributes.hpp>
#include <boost/log/utility/setup/console.hpp>
#include <boost/log/utility/setup/file.hpp>
#include <string>

namespace attrs = boost::log::attributes;
namespace expr = boost::log::expressions;
namespace keywords = boost::log::keywords;
namespace logging = boost::log;
namespace sinks = boost::log::sinks;
namespace src = boost::log::sources;

/*
$ cat foo_20240924_220112.711990_CST.log
2024-09-24 22:01:25.084288 CST [debug  ] main.cpp:11: This is a debug message.
2024-09-24 22:01:25.084423 CST [info   ] main.cpp:12: This is an info message.
2024-09-24 22:01:25.084539 CST [warning] main.cpp:13: This is a warning message.
2024-09-24 22:01:25.084628 CST [error  ] main.cpp:14: This is an error message.
2024-09-24 22:01:25.085912 CST [fatal  ] main.cpp:15: This is a fatal message.
2024-09-24 22:01:25.086041 CST [trace  ] main.cpp:10: This is a trace message.
$
*/

std::string timezone2() {
  char str[50];
  std::time_t tm = std::time(nullptr);
  std::tm local = *std::localtime(&tm);
  strftime(str, sizeof(str), "%Z", &local);
  return str;
}

void init_logging(const std::string &log_dir, const std::string &name) {
  const std::string pattern =
      std::string("_%Y%m%d_%H%M%S.%f_") + timezone2() + ".log";
  const size_t rotation_size = 1024 * 1024 * 1;
  const size_t max_files = 5;
  const size_t min_free_space = 1024ULL * 1024 * 1024 * 10;
  const size_t severity_len = std::strlen("warning");

  auto format = expr::stream
                << expr::format_date_time<boost::posix_time::ptime>(
                       "TimeStamp", "%Y-%m-%d %H:%M:%S.%f")
                << " " << expr::attr<std::string>("Timezone2") << " ["
                << std::left << std::setw(severity_len) << std::setfill(' ')
                << logging::trivial::severity << "] " << expr::smessage;

  auto fileSink = logging::add_file_log(
      keywords::file_name = log_dir + "/" + name + pattern,
      keywords::target_file_name = name + pattern,
      keywords::rotation_size = rotation_size, // in characters
      keywords::auto_flush = true, keywords::target = log_dir,
      keywords::max_size = rotation_size * max_files, // in bytes
      keywords::min_free_space = min_free_space,      // in bytes
      keywords::max_files = max_files,
      keywords::filter = logging::trivial::severity >= logging::trivial::trace,
      keywords::format = format);

  auto consoleSink = logging::add_console_log(
      std::clog,
      keywords::filter = logging::trivial::severity >= logging::trivial::trace,
      keywords::format = format);

  logging::core::get()->add_global_attribute(
      "Timezone2", logging::attributes::make_function<std::string>(&timezone2));

  // Add common attributes like TimeStamp
  logging::add_common_attributes();
}
$

$ cat log.h

#ifndef log_h
#define log_h

#include <boost/log/trivial.hpp>

// log macro
#define LOG(severity)                                                          \
  BOOST_LOG_TRIVIAL(severity) << __FILE__ << ":" << __LINE__ << ": "

void init_logging(const std::string &log_dir, const std::string &name);

#endif
$

$ cat main.cpp

#include "log.h"
#include <string>

int main() {
  const std::string log_dir = "logs"; // get executable directory
  const std::string name = "foo";
  init_logging(log_dir, name);

  for (;;) { // test rotation
    LOG(trace) << "This is a trace message.";
    LOG(debug) << "This is a debug message.";
    LOG(info) << "This is an info message.";
    LOG(warning) << "This is a warning message.";
    LOG(error) << "This is an error message.";
    LOG(fatal) << "This is a fatal message.";
  }
  return 0;
}
$

$ cat Makefile
# build dynamic library with -fPIC -shared
CXXFLAGS    = -std=c++2a -g # -O3 -fPIC # CXXFLAGS for .cpp
CPPFLAGS  = -MMD -MP -I/home/ljh/Downloads/boost_1_86_0 -DBOOST_LOG_DYN_LINK # -DNDEBUG
LDFLAGS   = -L/home/ljh/Downloads/boost_1_86_0/stage/lib # -shared
LDLIBS    = -lboost_log -lboost_log_setup -lboost_chrono -lboost_filesystem -lboost_thread -lboost_atomic
CC       = $(CXX) # link with CXX for .cpp
# target name is basename of one of the source files
main : $(patsubst %.cpp,%.o,$(wildcard *.cpp)) # .cpp
-include *.d
clean : ; -rm -fr *.o *.d glog
.PHONY : clean
$


---


#include "utf8.h"
#include <iostream>
#include <string>

// ascii, unicode, utf, cjk,
// icu, gnu iconv, utfcpp,
// https://github.com/nemtrif/utfcpp ;

// std::u32string utf8to32(const std::u8string& s);
// std::u32string utf8to32(const std::string& s);

#define cout2 (std::cout << __FILE__ << ":" << __LINE__ << ": ")
int main() {
  {
    std::string a = "ä½ å¥½ä¸–ç•Œ";
    cout2 << a.length() << ", ";
    for (auto c : a) {
      std::cout << c << " ";
    }
    std::cout << "\n";
  }

  {
    std::u8string a = u8"ä½ å¥½ä¸–ç•Œ";
    cout2 << a.length() << ", ";
    for (auto c : a) {
      std::cout << c << " ";
    }
    std::cout << "\n";
  }

  {
    std::u32string a = U"ä½ å¥½ä¸–ç•Œ";
    cout2 << a.length() << ", ";
    for (auto c : a) {
      std::cout << c << " ";
    }
    std::cout << "\n";
  }

  {
    std::string a = "ä½ å¥½ä¸–ç•Œ";
    std::u32string c = utf8::utf8to32(a);
    cout2 << c.length() << ", ";
    for (auto c2 : c) {
      std::cout << c2 << " ";
    }
    std::cout << "\n";
  }

  {
    std::string a = "ä½ å¥½ä¸–ç•Œ";
    std::u32string d = utf8::utf8to32(a);
    cout2 << d.length() << ", ";
    for (auto d2 : d) {
      std::cout << d2 << " ";
    }
    std::cout << "\n";
  }

  return 0;
}

/*

- utf-8 is compatible with existing ascii;
- utf-8 is byte sequence;
- utf-8 should be converted to utf-32,
    for character based index, slice or substring;

when it comes to unicode:
be specific about size, use std::u8string, char8_t instead of std::string, char;
be certain about the file encoding before parse it, utf-8, chinese gbk, etc.;

---

UTF-8:
1 to 4 bytes;
Memory-efficient, compatible with ASCII;
Variable-length encoding can complicate indexing;
Web content, network protocols, general text storage

UTF-16:
2 or 4 bytes;
Efficient for BMP characters, especially for East Asian scripts;
Variable-length encoding, not backward compatible with ASCII;
Applications working with East Asian scripts, Windows systems;

UTF-32:
Always 4 bytes;
Fixed length makes indexing easy;
Inefficient use of memory;
Situations where constant-time access is needed, specialized processing systems;

*/


---


// c++, character set, encoding, locale, ascii, gbk, unicode utf,
// cjk, chinese, japanese, korean,
// icu, utfcpp, gnu iconv,

/*

1. std::locale::global is for standard io, stdin, stdout, stderr;
2. imbue is for file specific file stream;
3. SetConsoleOutputCP, SetConsoleCP: for console stdin stdout on Windows;

$ locale
LANG="en_US.UTF-8"
$
$ locale -a | vi -
$
$ file -i cjkä¸­æ–‡.txt
cjkä¸­æ–‡.txt: text/plain; charset=utf-8
$
$ iconv -l | vi -
$
$ sudo dpkg-reconfigure locales # debian
$

C:\> chcp
936
C:\>

*/

#include <iostream>
#include <fstream>
#include <string>
#include <locale>
#include <codecvt>

#ifdef _WIN32
#include <windows.h>
#endif

int main() {
  // std::locale::global(std::locale("")); // use default locale
  // std::locale::global(std::locale("en_US.UTF-8")); // use utf-8

  // Set global locale to GBK (for handling CJK characters)
  std::locale::global(std::locale("zh_CN.GBK"));

#ifdef _WIN32
  // Windows-specific console setup for CJK character handling
  // learn.microsoft.com/en-us/windows/win32/intl/code-page-identifiers ;

  // SetConsoleOutputCP(65001); // utf-8
  // SetConsoleCP(65001);       // utf-8

  SetConsoleOutputCP(936); // chinese GBK
  SetConsoleCP(936);       // chinese GBK

#endif

  // Get the filename from the user (CJK characters supported)
  std::wcout << L"Enter filename (e.g., ä½ å¥½helloä¸–ç•Œ.txt): ";
  std::wstring filename;
  std::getline(std::wcin, filename);

  // Open/create the file
  std::wofstream outfile;

  // outfile.imbue(std::locale("en_US.UTF-8")); // Set locale for file stream

  outfile.imbue(std::locale("zh_CN.GBK")); // Set locale for file stream (GBK encoding)
  outfile.open(filename);

  if (!outfile.is_open()) {
    std::wcerr << L"Failed to open or create the file.\n";
    return 1;
  }

  // Write a CJK string to the file
  std::wstring text = L"ä½ å¥½helloä¸–ç•Œ";
  outfile << text << std::endl;
  outfile.close();

  // Now read the content from the file
  std::wifstream infile;

  // outfile.imbue(std::locale("en_US.UTF-8")); // Set locale for file stream

  infile.imbue(std::locale("zh_CN.GBK")); // Set locale for file stream
  infile.open(filename);

  if (!infile.is_open()) {
    std::wcerr << L"Failed to open the file for reading.\n";
    return 1;
  }

  // Output the file content to the console
  std::wstring line;
  while (std::getline(infile, line)) {
    std::wcout << L"Read from file: " << line << std::endl;
  }

  infile.close();

  return 0;
}


---


both compile and link should be with address sanitizer:
$ make -C src/main
c++ -fsanitize=address -Wall -Wextra -std=c++2a -g  -MMD -MP  -c -o main.o main.cpp
c++  -fsanitize=address   main.o   -o main
$

run the program built with address sanitizer on command line directly;
do not run executable built with address sanitizer in gdb debugger;

check address sanitizer:
$ src/main/main

check memory leak with address sanitizer:
$ LSAN_OPTIONS=verbosity=1:log_threads=1 src/main/main


---


ldd - print shared object dependencies;
nm - list symbols from object files;
objdump - display information from object files;
readelf - display information about ELF files;

$ ldd a.out

# static archive
$ ar -t libfoo.a # list member object files: foo.o bar.o

# shared object dynamic library
$ nm -a /path/to/libfoo.so | grep foo # symbol
$ nm -D /path/to/libfoo.so | grep foo # dynamic symbol
$ objdump -t /path/to/libfoo.so | grep ".text" # symbol table
$ objdump -T /path/to/libfoo.so | grep ".text" # dynamic symbol table
$ readelf -Ws /path/to/libfoo.so | grep FUNC

# in C,C++, when run a executable,
# if the dynamic library libfoo.so is not in current working directory,
# use LD_LIBRARY_PATH to specify the directory to it.

$ LD_LIBRARY_PATH=../boost_1_82_0/stage/lib  ./a.out
$ LD_LIBRARY_PATH=../boost_1_82_0/stage/lib  /path/to/a.out

#
# in python, when run a file with python: `python3 /path/to/foo.py`,
# the directory containing foo.py is added to sys.path,
# not necessary the current working directory is added to it.
# if the imported module in foo.py is not in the same directory with foo.py,
# use PYTHONPATH to specify the directory to it.
#
# PYTHONPATH=/path/to/imported/module  python3 foo.py
# PYTHONPATH=/path/to/imported/module  python3 /path/to/foo.py
#

---


// cppreference, Compound literals,
// html-book-20240610/reference/en/c/language/compound_literal.html ,

#include <stdio.h>

int *p = (int[]){2, 4};
const float *pc = (const float[]){1e0, 1e1, 1e2};

struct point {
  double x, y;
};

int main(void) {
  int n = 2, *p = &n;
  p = (int[2]){*p};

  void drawline1(struct point from, struct point to);
  void drawline2(struct point * from, struct point * to);
  drawline1((struct point){.x = 1, .y = 1}, (struct point){.x = 3, .y = 4});

  // it is legal in c, but error in c++.
  // error: taking the address of a temporary object [-Waddress-of-temporary]
  // [-Waddress-of-temporary] drawline2(&(struct point){.x = 1, .y = 1},
  // &(struct point){.x = 3, .y = 4});

  // create an variable for temporary use instead
  point p1 = {.x = 1, .y = 1};
  point p2 = {.x = 3, .y = 4};
  drawline2(&p1, &p2);
}

void drawline1(struct point from, struct point to) {
  printf("drawline1: `from` @ %p {%.2f, %.2f}, `to` @ %p {%.2f, %.2f}\n",
         (void *)&from, from.x, from.y, (void *)&to, to.x, to.y);
}

void drawline2(struct point *from, struct point *to) {
  printf("drawline2: `from` @ %p {%.2f, %.2f}, `to` @ %p {%.2f, %.2f}\n",
         (void *)from, from->x, from->y, (void *)to, to->x, to->y);
}


---


/*

compile boost:

$ tar xf boost_1_86_0.tar.bz2
$ cd boost_1_86_0
$ ./bootstrap  # generate b2
$ ./b2         # build only, do not install ;

# Makefile:

CPPFLAGS += -I/home/ljh/app/boost_1_86_0
LDFLAGS += -L/home/ljh/app/boost_1_86_0/stage/lib

*/

#include <boost/multiprecision/cpp_dec_float.hpp>
#include <boost/multiprecision/cpp_int.hpp>
#include <boost/safe_numerics/safe_integer.hpp>
#include <iostream>
#include <string>
#include <vector>

using namespace boost::safe_numerics;
using namespace boost::multiprecision;

// typedef number<cpp_dec_float<50>> cpp_dec_float_50;
// typedef number<cpp_dec_float<100>> cpp_dec_float_100;

// safe numerics
safe<uint> f1(safe<unsigned long long> a, safe<unsigned long long> b) {
  return a + b;
}

// multi precision, checked
checked_uint256_t f2(checked_uint256_t a, checked_uint256_t b) { return a + b; }

// multi precision
cpp_int f3(cpp_int a, cpp_int b) { return a + b; }

// multi precision, floating point
cpp_dec_float_100 f4(cpp_dec_float_100 a, cpp_dec_float_100 b) { return a + b; }

int main() {
  {
    auto max = ULLONG_MAX;
    auto min = 0;
    // auto a1 = f1(max, max); // error, positive overflow
    auto a2 = f1(100, 200);
  }

  {
    auto mp_max = std::numeric_limits<uint256_t>::max();
    auto mp_min = std::numeric_limits<uint256_t>::min();
    // auto b1 = f2(mp_max, mp_max); // error, value overflows
    auto b2 = f2(100, 200);
    auto b3 = f3(mp_max, mp_max);
  }

  {
    double a1 = 1.2300000000001;
    double b1 = 1.00;
    double c1 = a1 + b1;
    std::cout << __LINE__ << ": " << c1 << "\n";

    cpp_dec_float_100 a2("1.2300000000001");
    cpp_dec_float_100 b2("1.00");
    auto c2 = f4(a2, b2);
    std::cout << __LINE__ << ": " << c2.str() << "\n"; // ok
  }
  return 0;
}


---


// C++ Core Guidelines:
// If a future evolution of std::span adds bounds checking, gsl::span can be removed.

// CPPFLAGS += -I/home/ljh/app/GSL/include/

#include <gsl/gsl> // github.com/microsoft/gsl,
#include <vector>

int main() {
  std::vector v = {1, 2, 3}; // or builtin array in C language.
  gsl::span s = v;

  // undefined and hard to locate, no core dump, address sanitizer helps.
  // v[3] = 1;

  // gsl:span bound check, generates core dump, address sanitizer not work.
  // s[3] = 1;

  return 0;
}


---


// CPPFLAGS += -I/home/ljh/app/GSL/include/

// #include <boost/safe_numerics/safe_integer.hpp>
#include <gsl/gsl>
#include <iostream>
#include <iterator>
#include <string>
#include <vector>

// using namespace boost::safe_numerics;

int main() {
  char a[20] = "hello"; // size: 10, 20,
  char b[10];           // size: 10,
  std::vector<char> c;

  // std::copy(std::begin(a), std::end(a), std::begin(b));
  // std::copy(std::begin(a), std::end(a), std::back_inserter(c));

  // gsl::span is with bound check,
  // std::span removed bound check.

  gsl::span s1(a);
  gsl::span s2(b);
  // gsl::copy(s1, s2); // bound check, src: 20, dest: 10,

  // s1[99] = 'a'; // bound check

  return 0;
}


---


int main() {
  int a[3] = {1,2,3};
  a[0] = 1;
  a[3] = 1;       // asan, address sanitize
  a[102400] = 1;  // ubsan, undefined behavior sanitize
  return 0;
}

/*

# address (including leak), undefined behavior sanitizer

CXXFLAGS += -fsanitize=address -fsanitize=undefined
LDFLAGS += -fsanitize=address -fsanitize=undefined

*/


---


# build dynamic library with -fPIC -shared
CFLAGS = -g # -O3 -fPIC # CXXFLAGS for .cpp
CPPFLAGS = -MMD -MP # -I../foo -DNDEBUG
LDFLAGS  = # -L../foo -shared
LDLIBS   = # -lfoo
#CC       = $(CXX) # link with CXX for .cpp

# target name is basename of one of the source files
main: $(patsubst %.c,%.o,$(wildcard *.c)) # .cpp
-include *.d
clean: ; $(RM) *.o *.d main
.PHONY: clean

# archive static library target filename suffix is `.a`
# $ make libfoo.a
(%) : % ;
%.a : ; $(AR) $(ARFLAGS) $@ $?

# non archive(member) syntax, gnu make manual 10.5.3 automatic variables: `$?`
#ARFLAGS = rv
libfoo.a: $(patsubst %.c,%.o,$(wildcard *.c)) # .cpp

# archive(member) syntax `a(m)`, requires ar 2.43 option `U` on debian 12
#ARFLAGS = rvU
#libfoo.a: libfoo.a($(patsubst %.c,%.o,$(wildcard *.c))) # .cpp

# use clang for C program:
#CC        = clang

# use clang++ for C++ program, link with libc++ instead of libstdc++,
# $ sudo apt install clang llvm lldb libc++-dev libc++abi-dev
#CXX       = clang++
#CC        = $(CXX) # link with CXX for .cpp
#CXXFLAGS += -stdlib=libc++
#LDFLAGS  += -stdlib=libc++

# fully static link: libc6 , libstdc++6 , etc. ,
#LDFLAGS  += -static

# static link: libfoo.a , dynamic link: libbar.so ,
#LDFLAGS  += -Wl,-Bstatic -lfoo -Wl,-Bdynamic -lbar

# additional flags
CPPFLAGS += -I/home/ljh/app/GSL/include/
CPPFLAGS += -I/home/ljh/app/boost_1_86_0/
LDFLAGS  += -L/home/ljh/app/boost_1_86_0/stage/lib

CXXFLAGS += -std=c++2a -Wall -Wextra -Wpedantic

# https://github.com/google/sanitizers/issues/1039#issuecomment-453607726 ,
#   "asan+lsan+ubsan is fine, the rest should run separately."  --kcc, Jan 12, 2019

# address (including leak), undefined behavior sanitizers,
# CXXFLAGS += -fsanitize=address -fsanitize=leak -fsanitize=undefined
# LDFLAGS += -fsanitize=address -fsanitize=leak -fsanitize=undefined

# thread sanitizer,
# CXXFLAGS += -fsanitize=thread
# LDFLAGS += -fsanitize=thread

# https://github.com/google/sanitizers/issues/1039#issuecomment-453306241 ,
#   "GCC doesn't have msan at all."  --kcc, Jan 11, 2019

# memory sanitizer, (gcc has no msan. use clang, clang++, if needed)
# CXXFLAGS += -fsanitize=memory -fPIE
# LDFLAGS += -fsanitize=memory -pie


---


# Makefile
# executable, shared object dynamic library, archive static library

# build dynamic library with -fPIC -shared
CFLAGS   = -g # -O3 -fPIC # CXXFLAGS for .cpp
CPPFLAGS = -MMD -MP # -I../foo -DNDEBUG
ARFLAGS  = -rvU
LDFLAGS  = # -L../foo -shared -static
LDLIBS   = # -lfoo
#CC      = $(CXX) # link with CXX for .cpp

all : main libfoo.so libfoo.a

# target name is basename of one of the source files
main : $(patsubst %.c,%.o,$(wildcard *.c)) # .cpp

%.so : ; $(CC) $(LDFLAGS) $^ $(LDLIBS) -o $@
libfoo.so : $(patsubst %.c,%.o,$(wildcard *.c)) # .cpp

# fully static link archive .a with -static
(%) : % ;
%.a : ; $(AR) $(ARFLAGS) $@ $?
libfoo.a : libfoo.a($(patsubst %.c,%.o,$(wildcard *.c))) # .cpp

-include *.d

clean : ; $(RM) *.o *.d main libfoo.so libfoo.a
.PHONY : all clean


---


1.

libfoo.a : libfoo.a($(patsubst %.c,%.o,$(wildcard *.c))) # .cpp

If the static library archive is the only target of .o object files,
in the first build when the archive does not exist, after create the new archive,
the object files will be removed.
When the archive already exists, the next build will replace the object archive(member),
and the .o object files are not removed anymore.

2.

For ar utility on GNU Linux, when ARFLAGS is without U,
it is the deterministic mode or reproducible build archive.
the timestamp of the object archive(member) is reset to zero in the target.
It renders the target being always outdated and rebuilds the target.

$ ar -tv libfoo.a
rw-r--r-- 0/0  78776 Jan  1 08:00 1970 foo.o
$

When the ARFLAGS is with U, the timestamp is kept in archive(member) in the target.

$ ar -tv libfoo.a
rw-rw-r-- 1000/1000  78776 Jan  1 23:49 2025 foo.o
$


---


# gnu make manual, chapter 10.2 Catalogue of Built-In Rules
# To see the full list of default rules and variables available in your version of GNU make,
# run â€˜make -pâ€™ in a directory with no makefile.
# or in vim :r !make -p

# the implicit rule which is built-in gnu make for updating archive is:

  (%): %
  #  recipe to execute (built-in):
    $(AR) $(ARFLAGS) $@ $<

# it needs the archive(member) syntax
# and the ar option U on gnu linux to trigger it,
# with the ar Option U, the timestamp is taken into account.
# make utility needs the timestamp to tell if prerequisites are newer than target.

  ARFLAGS = rvU
  libfoo.a: libfoo.a($(patsubst %.c,%.o,$(wildcard *.c)))

# the non archive(member) syntax is also mentioned
# in gnu make manual, chapter 10.5.3 Automatic Variables: $? as below

  lib: foo.o bar.o lose.o win.o
    ar r lib $?

# so this also works for updating archive:

  libfoo.a: $(patsubst %.c,%.o,$(wildcard *.c))


---


# what if library file name is just `foo`,
# and does not have prefix `lib` and suffix `.so` , `.a` ,
# and filename is not like: libfoo.so , libfoo.a ,

1. make symbolic link for them

$ ln -sf foo libfoo.a
$ ln -sf foo libfoo.so

2. or use `-l:foo` with colon : and followed by the exact full filename,
  this works even for the filename with prefix and suffix too,

LDLIBS   = -l:foo
LDLIBS   = -l:libfoo.a
LDLIBS   = -l:libfoo.so

3. but `-lfoo` without colon : can be easily switch between .so and .a ,
  if -static is used, it links to .a automatically,
LDFLAGS += # -static
LDLIBS   = -l:foo


---


# https://www.jetbrains.com/help/clion/google-sanitizers.html ,

set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fsanitize=[sanitizer_name] -g")

For [sanitizer_name] use one of the following:
  address (leak),
  undefined,
  memory,
  thread,


---


# How to use simultaneously Asan and Msan?
# https://github.com/google/sanitizers/issues/1039#issuecomment-453607726 ,
#   "asan+lsan+ubsan is fine, the rest should run separately."  --kcc.

# address/leak sanitizer, https://github.com/google/sanitizers/wiki/AddressSanitizer,
# undefined behavior sanitizer, https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html,


# https://gcc.gnu.org/onlinedocs/gcc/Instrumentation-Options.html ,
3.12 Program Instrumentation Options,

-fsanitize=address (cannot be combined with thread, hwaddress);
  -fsanitize=leak (included in address, cannot be combined with thread);
  -fsanitize=undefined;

-fsanitize=thread (cannot be combined with address, leak);

-fsanitize=memory (gcc has no msan. use clang if needed);

https://github.com/google/sanitizers/issues/1039#issuecomment-453306241 ,
  "GCC doesn't have msan at all."  --kcc, Jan 11, 2019


---


#include <gsl/gsl>
#include <memory>

// using namespace boost::safe_numerics;

int main() {
  {
    int a[3] = {1, 2, 3};
    // a[3] = 1;
    // a[102400] = 1;

#define N 3
    int n = 3;
    gsl::span<int, N> s1(a);
    gsl::span<int, N> s2(a, n);
    gsl::span<int> s3(a, n);
    // s[3] = 1;
    // s[102400] = 1;
  }

  {
    int *p = new int[3];
    // p[3] = 1;
    // p[102400] = 1;

    gsl::span<int, 3> s(p, 3);
    // s[3] = 1;
    // s[102400] = 1;

    delete[] p;
  }

  {
    std::unique_ptr<int[]> p(new int[3]);
    // std::shared_ptr<int[]> p(new int[3]);
    // p[3] = 1;
    // p[102400] = 1;

    gsl::span<int, 3> s(p.get(), 3);
    // s[3] = 1;
    // s[102400] = 1;
  }

  return 0;
}


---



```
C++ priemr 5th:

12.1.4 Smart Pointers and Exceptions,

Using Our Own Deletion Code:

By default, shared_ptrs assume that they point to dynamic memory.
Hence, by default, when a shared_ptr is destroyed, it executes delete on the pointer it holds.
To use a shared_ptr to manage a connection, we must first define a function to use in place of delete.
It must be possible to call this deleter function with the pointer stored inside the shared_ptr.
In this case, our deleter must take a single argument of type connection*:

  void end_connection(connection *p) { disconnect(*p); }

When we create a shared_ptr,
we can pass an optional argument that points to a deleter function (Â§ 6.7, p. 247):

  void f(destination &d /* other parameters */) {
  connection c = connect(&d);
  shared_ptr<connection> p(&c, end_connection);
    // use the connection
    // when f exits, even if by an exception, the connection will be properly closed
  }

When p is destroyed, it wonâ€™t execute delete on its stored pointer.
Instead, p will call end_connection on that pointer.
In turn, end_connection will call disconnect, thus ensuring that the connection is closed.
If f exits normally, then p will be destroyed as part of the return.
Moreover, p will also be destroyed, and the connection will be closed, if an exception occurs.
```


```
// https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines ,

Discussion: Never return or throw while holding a resource not owned by a handle
Reason That would be a leak.

Example

void f(int i)
{
  FILE* f = fopen("a file", "r");
  ifstream is { "another file" };
  // ...
  if (i == 0) return;
  // ...
  fclose(f);
}

If i == 0 the file handle for a file is leaked. On the other hand,
the ifstream for another file will correctly close its file (upon destruction).
If you must use an explicit pointer, rather than a resource handle with specific semantics,
use a unique_ptr or a shared_ptr with a custom deleter:

void f(int i)
{
  unique_ptr<FILE, int(*)(FILE*)> f(fopen("a file", "r"), fclose);
  // ...
  if (i == 0) return;
  // ...
}

Better:

void f(int i)
{
  ifstream input {"a file"};
  // ...
  if (i == 0) return;
  // ...
}

```


```
8.2.1 Using File Stream Objects:

When an fstream object is destroyed, close is called automatically.
```


The deleter is only needed when the non-memory resources
like file handle, network or database connection, etc., is used directly.

Encapsulate the resource into a class like ifstream,
call the deleter in the class destructor like the ifstream close the file in its destructor,
then the deleter usage is not needed.

But dynamic array needs deleter synatx call ` delete []p `,
which can not be replaced by destructor directly.


---


Templates and Compile-Time Polymorphism:
Templates in C++ allow functions and classes to operate with generic types.
When you define a template, the compiler generates the appropriate function or
class for each type used in the template.
This mechanism is known as compile-time polymorphism because the decision about
which function or class to use is made at compile time.

Virtual Functions and Runtime Polymorphism:
Virtual functions enable you to achieve runtime polymorphism in C++.
They allow derived classes to override methods defined in base classes.
The decision about which function to invoke is made at runtime based on the type
of the object pointed to by the base class pointer/reference.


---


$ gcc a.c # -o a.out # default output executable name
$
$ a.out
$ a.out foo 100
$ a.out < input.txt
$
$ gdb a.out core.1234
$ gdb
) file a.out
) core-file core.1234
) set args foo 100
) b 5 # break
) b main.cpp:5
) run
) run < input.txt # input redirect
) n # next # step over
) s # step # step into
) finish # step out
) continue
) p variable_x # print
) where
) list
) bt # backtrace
) quit
$


---


// strcpy, K&R C, chapter 5.5 ,

void strcpy(char *s, char *t) {
  while (*s++ = *t++)
    ;
}

---

// if the pivot selection does not evenly partition the elements every time,
// the recursion goes deeper which makes the quick sort perform worse.
// this is similar to unbalanced tree vs. a balanced search tree.

// for cases like already sorted elements, reverse sorted elements,
// all equal elements, it is better to check all elements in an iteration
// which is O(n) before perform quick sort to avoid falling into the worst O(n^2).
// this is why the C qsort and c++ std::sort are both not just quick sort,
// they both are combination of hybrid methods.
//

// quick sort, K&R C, chapter 4.10 ,
// how to understand the qsort implementation in K&R C 2nd:
// 1. it seems that it only handles the smaller elements explicitly,
//    it puts the smaller elements at the beginning.
//    but this also naturally causes the equal and larger elements are following the smaller elements.
// 2. the restore swap puts the partition element after the smaller elements.
//    this restore the elements relationship,
//    but not necessary the original index of the partition element.

#include <stdio.h>

void swap(int v[], int i, int j) {
  int tmp = v[i];
  v[i] = v[j];
  v[j] = tmp;
}

void qsort(int v[], int left, int right) {
  if (left >= right) {
    return;
  }
  swap(v, left, (left + right) / 2); // move partition elem
  int last = left;
  for (int i = left + 1; i <= right; i++) {
    if (v[i] < v[left]) {
      swap(v, ++last, i);
    }
  }
  swap(v, left, last); // restore partition elem
  qsort(v, left, last - 1);
  qsort(v, last + 1, right);
}

int main() {
  int arr[] = {2, 1, 5, 4, 3};

  qsort(arr, 0, sizeof(arr) / sizeof(*arr) - 1);
  for (auto e : arr) {
    printf("%d\n", e);
  }

  return 0;
}

// sort the vector in ascending order
void qsort2(std::vector<int> &v, int left, int right) {
  if (left >= right) {
    return;
  }

  auto mid = (left + right) / 2;

  for (auto i = left; i < mid;) {
    if (v[i] > v[mid]) {
      v.insert(begin(v) + mid + 1, v[i]);
      v.erase(begin(v) + i);
      mid--;
    } else {
      i++;
    }
  }

  for (auto i = mid + 1; i <= right; i++) {
    if (v[i] < v[mid]) {
      v.insert(begin(v) + mid, v[i]);
      v.erase(begin(v) + i + 1);
      mid++;
    }
  }

  qsort2(v, left, mid - 1);
  qsort2(v, mid + 1, right);
}

---

// binary search, K&R C chapter 3.3, https://leetcode.cn/problems/binary-search/ ,

int binary_search(int arr[], int left, int right, int target) {
  while (left <= right) {
    int mid = (left + right) / 2;

    if (arr[mid] == target) {
      return mid;
    } else if (arr[mid] < target) {
      left = mid + 1;
    } else if (arr[mid] > target) {
      right = mid - 1;
    }
  }
  return -1;
}

---

// fibonacci, https://leetcode.cn/problems/fibonacci-number/ ,

int fib(int n) {
  if (n <= 1) {
    return n;
  }
  return fib(n-1) + fib(n-2);
}

---

// reverse linked list, https://leetcode.cn/problems/reverse-linked-list/ ,

ListNode* reverseList(ListNode* head) {
  ListNode* prev = nullptr;
  ListNode* curr = head;
  ListNode* next = nullptr;

  while (curr) {
    next = curr->next;
    curr->next = prev;
    prev = curr;
    curr = next;
  }
  return prev;
}


---


// iSH, Alphine, Linux, iOS, iPhone, iPadOS,

https://github.com/ish-app/ish ,

$ vi /etc/apk/repositories
# default
#http://dl-cdn.alpinelinux.org/alpine/v3.12/main
#http://dl-cdn.alpinelinux.org/alpine/v3.12/community

# mirror source
# keep version number "n.nn" same as the existing ones in file
http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.12/main
http://mirrors.tuna.tsinghua.edu.cn/alpine/v3.12/community

#[ iSH v1.2.3 has builtin apk, no need to manual download
# $ tar xf apk-tools-static-2.10.5-r1.apk
# $ ./sbin/apk.static add apk-tools
#]

$ apk update
$ apk upgrade
$ apk add build-base alpine-sdk gdb bash openssh vim sudo shadow abuild alpine-conf tzdata samba util-linux boost boost-dev

$ apk add man-pages mandoc gcc-doc gdb-doc coreutils-doc binutils-doc busybox-doc shadow-doc bash-doc

$ adduser -h /home/ljh ljh
$ addgroup ljh wheel
$ usermod -aG wheel ljh
$ sg wheel

$ bash
$ sudo vi /etc/passwd
root:x:0:0:root:/root:/bin/bash
$

# $ sudo chsh -s /bin/bash ljh

$ vi .bash_profile
PS1='\$ '
set -o vi
export HISTCONTROL="ignoredups:erasedups:ignorespace"
export PROMPT_COMMAND='history -a'
$

$ vi .inputrc
set editing-mode vi
$

$ apk info -L boost-dev  # file path directory
$ apk info --who-owns /bin/ls  # package
/bin/ls .. is owned by busybox-1.xx
$ apk info -R build-base  # dependencies

# list package content
# install destination path
$ apk info -L boost-dev
boost-dev-1.72.0-r6 contains:
usr/include/boost/align.hpp
...
usr/lib/libboost_atomic.so
...

---

if vi open file in wrong character encoding,
use vim, neovim instead,

---

//man pages wrong characters

$ man chown | vim -M +MANPAGER -
$

# or,
$ vi ~/.bashrc
export MANPAGER="vim -M +MANPAGER -"

$ man chown
$


---


/*
https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/memcpy-wmemcpy?view=msvc-170

void *memcpy( void *dest, const void *src, size_t count );

memcpy copies count bytes from src to dest; wmemcpy copies count wide
characters. If the source and destination regions overlap, the behavior of
memcpy is undefined. Use memmove to handle overlapping regions.
*/

/*
https://learn.microsoft.com/en-us/cpp/c-runtime-library/reference/memmove-wmemmove?view=msvc-170

void *memmove( void *dest, const void *src, size_t count );

Copies count bytes (memmove) or characters (wmemmove) from src to dest. If some
portions of the source and the destination regions overlap, both functions
ensure that the original source bytes in the overlapping region are copied
before being overwritten.
*/

// crt_memcpy.c
//
// Illustrate overlapping copy:
//
// memmove always handles it correctly;
//
// memcpy may handle it correctly (or incorrectly).
//

#include <memory.h>
#include <stdio.h>
#include <string.h>

const char *str0 = "aabbcc";
char str1[7] = str0;

int main(void) {

  // if src and dest point to same array and if there is overlap,
  // no matter src is before or after dest,
  // it renders memcpy undefined, use memmove instead in case of overlap.

  // overlap case 1: src is before dest
  memcpy(str1 + 2, str1, 4);  // undefined!
  memmove(str1 + 2, str1, 4); // ok

  // overlap case 2: src is after dest
  // memcpy(str1, str1 + 2, 4); // undefined!
  // memmove(str1, str1 + 2, 4); // ok
}

/*

both reported by ` -Wall `:

main.cpp:10:9: warning: â€˜void* memcpy(void*, const void*, size_t)â€™ accessing 4 bytes at offsets 2 and 0 overlaps 2 bytes at offset 2 [-Wrestrict]
   10 |   memcpy(str1 + 2, str1, 4); // overlap
      |   ~~~~~~^~~~~~~~~~~~~~~~~~~
main.cpp:11:9: warning: â€˜void* memcpy(void*, const void*, size_t)â€™ accessing 4 bytes at offsets 0 and 2 overlaps 2 bytes at offset 2 [-Wrestrict]
   11 |   memcpy(str1, str1 + 2, 4); // overlap


both reported by asan (with clang on macOS):

$ make -C src/main && src/main/main
c++ -g  -std=c++2a -Wall -Wextra -Wpedantic -Wcast-qual -Wconversion -Wfloat-equal -Wformat -Woverflow -Wsign-conversion -Wuninitialized -Wwrite-strings -fsanitize=address -fsanitize=undefined  -MMD -MP  -I/home/ljh/app/GSL/include/ -I/home/ljh/app/boost_1_86_0/  -c -o main.o main.cpp
c++   -L/home/ljh/app/boost_1_86_0/stage/lib -fsanitize=address -fsanitize=undefined   main.o   -o main
ld: warning: directory not found for option '-L/home/ljh/app/boost_1_86_0/stage/lib'
=================================================================
==1245==ERROR: AddressSanitizer: memcpy-param-overlap: memory ranges [0x00010c1fa062,0x00010c1fa066) and [0x00010c1fa060, 0x00010c1fa064) overlap
    #0 0x10c678e7d in __asan_memcpy+0xad (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x48e7d)
    #1 0x10c1f5e42 in main main.cpp:10
    #2 0x11501852d in start+0x1cd (dyld:x86_64+0x552d)

0x00010c1fa062 is located 2 bytes inside of global variable 'str1' defined in 'main.cpp:7:6' (0x10c1fa060) of size 7
  'str1' is ascii string 'aabbcc'
0x00010c1fa060 is located 0 bytes inside of global variable 'str1' defined in 'main.cpp:7:6' (0x10c1fa060) of size 7
  'str1' is ascii string 'aabbcc'
SUMMARY: AddressSanitizer: memcpy-param-overlap (libclang_rt.asan_osx_dynamic.dylib:x86_64h+0x48e7d) in __asan_memcpy+0xad
==1245==ABORTING
zsh: abort      src/main/main
$
*/


---


#include <concepts>
#include <iostream>

auto sum1(auto a, auto b) requires requires { a + b; }
{ return a + b; }

auto sum2(auto a, auto b) requires std::invocable<std::plus<>, decltype(a), decltype(b)>
{ return a + b; }

auto sum3(std::integral auto a, std::integral auto b)
{return a + b;}

template <std::integral T>
T sum4(T a, T b) { return a + b; }

template <typename T> requires std::integral<T>
T sum5(T a, T b) { return a + b; }

template <typename T> requires std::is_integral_v<T> || std::is_floating_point_v<T>
T sum6(T a, T b) { return a + b; }

template <typename T>
T sum7(T a, T b) requires std::is_arithmetic_v<T>
{ return a + b; }


template <typename T>
T concat1(T a, T b) requires std::invocable<std::plus<>, T, T>
{ return a + b; }

template <typename T>
T concat2(T a, T b) requires requires { a + b; }
{ return a + b; }

template <typename T>
T concat3(T a, T b) requires std::convertible_to<decltype(a + b), T>
{ return a + b; }


int main()
{
  std::cout << sum1(1, 2) << "\n";
  std::cout << sum2(1, 2) << "\n";
  std::cout << sum3(1, 2) << "\n";
  std::cout << sum4(1, 2) << "\n";

  std::cout << sum3(1.0, 3.14) << "\n";
  std::cout << sum4(1.0, 3.14) << "\n";

  // std::cout << sum1("abc", "efg") << "\n";

  std::cout << concat1(std::string("abc"), std::string("efg")) << "\n";

}


---


// Use `assert()` to check correctness in debug builds.
// Omit these checks in release builds for performance using `CPPFLAGS += -DNDEBUG`.
// Use assert() to check issues like buffer overflows and array index out-of-bounds,
// but not for specific values like if `user_input_name == "tom"`.

int main() {
  int arr[] = {1, 2, 3};
  int *ptr = arr + 1; // address arithmetic with pointer can take negative offset.
  int offset = -5; // offset -1 will be fine.

  // sizeof only works for array.
  // use the specified size for malloc'ed buffer.
  int len = sizeof(arr) / sizeof(*arr);

  // CPPFLAGS += -DNDEBUG  # turn off assert in release build
  assert(ptr + offset >= arr && ptr + offset < arr + len);

  printf("%d\n", ptr[offset]); // valid
}


---


strncpy, strcpy,
snprintf,
strcmp,
strncat,
memcpy, memmove, memcmp, memset,
fgets, std::getline,

// Linux manpages changed those description.
// keep the following from macOS manpages.

1.
char *strcpy(char *restrict dst, const char *restrict src);
strcpy(): copy the string src to dst (including the terminating â€˜\0â€™ character.)
The programmer is responsible for allocating a destination buffer large enough, that is, strlen(src) + 1.
// Or, the src buffer should be 1 letter shorter than dst.

2.
char *strncpy(char * dst, const char * src, size_t len);
strncpy(): copy at most len characters from src into dst.
If src is less than len characters long, the remainder of dst is filled with â€˜\0â€™ characters.
Otherwise, dst is not terminated.
// make sure destination buffer large enough too.

Because strncpy() does not guarantee to NUL terminate the string itself, this must be done explicitly.

  char buf[1024];
  strncpy(buf, input, sizeof(buf) - 1);
  buf[sizeof(buf) - 1] = '\0';


---


#include <iostream>

int main() {
  int arr[] = {10,20,30,};

  // range for
  for (auto i: arr){
    std::cout << __LINE__ << ": " << i << "\n";
  }

  // classic for
  for (size_t i = 0; i < sizeof(arr)/sizeof(*arr); i++) {
    assert(i >= 0 && i < sizeof(arr)/sizeof(*arr));
    std::cout << __LINE__ << ": " << arr[i] << "\n";
  }

  // reverse
  for (auto i = sizeof(arr)/sizeof(*arr); i > 0; i--) {
    assert(i - 1 >= 0 && i - 1 < sizeof(arr)/sizeof(*arr));
    std::cout << __LINE__ << ": " << arr[i - 1] << "\n";
  }

  for (auto p = arr + sizeof(arr)/sizeof(*arr) - 1; p >= arr; p--) {
    std::cout << __LINE__ << ": " << *p << "\n";
  }

  return 0;
}


---


#include <iostream>

// an array decays to a pointer when passed as argument.
// array can not be copied, assigned or returned.
void foo1(int *arr, int n){
  for (auto i = 0; i < n; i++){
    if (arr[i]) std::cout << arr[i] << ", ";
  }
  std::cout << "\n";
}

void foo2(int (*arr)[10]){
  for (size_t i = 0; i < sizeof(*arr)/sizeof(**arr); i++){
    if ((*arr)[i]) std::cout << (*arr)[i] << ", ";
  }
  std::cout << "\n";
}

// return p; // NO
// When foo3() returns, the stack unwinds (destroying arr) before the
// std::string constructor runs. The std::string constructor then reads
// invalid memory (p is now a dangling pointer). It is Undefined Behavior.
std::string foo3(){
  char arr[] = "abc";
  char *p = arr;
  // return p; // NO
  return std::string(p); // OK
}

int main() {
  int arr[10] = {10,20,30,};
  foo1(arr, sizeof(arr)/sizeof(*arr));
  foo2(&arr);

  std::cout << foo3() << "\n";

  return 0;
}


---


1. std::vector<T>& vs std::span<T>

Using std::vector<T>& is fine if:
You always work with a std::vector (not C arrays, std::array, or subranges).
You need to modify the vector (e.g., resize it).
You donâ€™t care about supporting other contiguous containers.

When std::span<T> is better:
You want to accept any contiguous data (C arrays, std::array, std::vector, subranges).
You only need a view (no resizing, just element access).
You want bounds safety (span knows its size, unlike raw pointers).

Example:

// Only works with std::vector
void process_vec(std::vector<int>& vec) {
  for (auto& x : vec) x *= 2;
}

// Works with std::vector, std::array, C arrays, etc.
void process_span(std::span<int> sp) {
  for (auto& x : sp) x *= 2;
}

int main() {
  std::vector<int> vec = {1, 2, 3};
  int arr[] = {4, 5, 6};

  process_vec(vec);  // OK
  // process_vec(arr); // ERROR: Doesn't work with C arrays!

  process_span(vec); // OK
  process_span(arr); // OK
}

2. std::string& vs std::string_view

Using std::string& is fine if:
You always work with a std::string (not const char* or string literals).
You need to modify the string (e.g., append, resize).
You donâ€™t care about supporting non-std::string inputs.

When std::string_view is better:
You want to accept any string-like data (std::string, const char*, literals).
You only need read-only access (no modification).
You want to avoid copies (e.g., when passing substrings).

Example:

// Only works with std::string
void modify_str(std::string& s) {
  s += "!";
}

// Works with std::string, const char*, literals, etc. (read-only)
void print_str(std::string_view sv) {
  std::cout << sv << "\n";
}

int main() {
  std::string s = "Hello";
  const char* cstr = "World";

  modify_str(s);    // OK
  // modify_str(cstr); // ERROR: Doesn't work with C strings!

  print_str(s);     // OK
  print_str(cstr);  // OK
  print_str("Hi");  // OK
}


---


5.7 Recursive Use of make
https://www.gnu.org/software/make/manual/html_node/Recursion.html ,

Projects containing source code are under the src directory;
One project - one directory - one Makefile;
The top src/Makefile will call the src/main/Makefile, src/foo/Makefile, etc;
Each project has its own directory;
No necessary to make extra nested directories under individual project;

// This is similar to IDE like Visual Studio.
// Each project has its own directory.
// Multiple projects are organized in a solution.


$ pwd
/home/user1/project/hello_cpp
$
$ ls
doc  src
$
$ tree
.
â”œâ”€â”€ doc
â”‚   â””â”€â”€ Readme.txt
â””â”€â”€ src
    â”œâ”€â”€ foo
    â”‚   â”œâ”€â”€ foo.cpp
    â”‚   â”œâ”€â”€ foo.h
    â”‚   â””â”€â”€ Makefile
    â”œâ”€â”€ main
    â”‚   â”œâ”€â”€ main.cpp
    â”‚   â””â”€â”€ Makefile
    â””â”€â”€ Makefile

$


---


in c, static variables and file scope global variables are default initialized with zero.
If initializers are provided, they must be compile-time constant expressions.
static variable is initialized only once.
local variables are default initialized with random value.

in c++, static variables and file scope variables can be initialized with non constant values,
eg. results of function calls.


---


how not to use exception in C++?


"We do not use C++ exceptions" -- google c++ style guide.


// 1. do not catch them! let the program stop.
// 2. do not throw in your own code.
// 3. figure out why the other code throws.
// 4. try to negotiate or meet the condition to avoid throwing.


https://stackoverflow.com/questions/7249378/disabling-c-exceptions-how-can-i-make-any-std-throw-immediately-terminate ,

Option #1: Simply never catch exceptions.

Exceptions don't have much overhead when they're not thrown or caught;
if you're throwing and not prepared to catch, well, you're doing to die anyway,
so the performance impact at that point is trivial.
Note also that stack unwinding will not be performed if an exception is not handled;
the program will simply terminate without performing stack unwinding.

It's important to note that, in G++, exceptions have almost no overhead when not
actually thrown. G++ generates extra information sufficient to trace back the
execution of the program through the stack, and some extra code to invoke
destructors, etc - however none of this extra code or data is ever used until an
exception is actually thrown. So you should not see a performance difference
between code with exceptions enabled but not used and code with exceptions
disabled (through whatever mechanism).

Option #2: Pass -fno-exceptions.

- bdonlan, Aug 30, 2011 at 20:32


+1; just don't catch exceptions. That's one of the reasons they're there for.
â€“ Seth Carnegie CommentedAug 30, 2011 at 20:36


yes, all of my advice is G++-specific. After all, the standard doesn't specify
any method to completely neuter exceptions :)
â€“ bdonlan CommentedAug 30, 2011 at 22:32


use -fno-exceptions turns all standard library throw's into a call to std::abort().
That handles the part you can't modify directly, the rest is to not use them at
all in your code.

Of course, I really doubt your justification in doing this. You only "lose"
performance when you actually throw, and you're throwing out a significant and
helpful bit of the language.
- GManNickG, Aug 30, 2011 at 20:34


Just don't catch them anywhere in your code.
In that case, a termination handler will be called and your program will "crash".
- user405725, answered Aug 30, 2011 at 20:31


---


passing function argument by reference (or pointer) ;
return by value (return value optimization) ;
if the parameter is read-only, passing by const reference (or pointer) ;
array decay into pointer, void f(int *arr, int size); better to use span ;
use assert to check for array bounds at debug build, turn off with CPPFLAGS += NDEBUG ;
use shared_ptr for reference count ;

initialize with equal sign = for builtin types: int, char, etc. ;
initialize with curly braces {} for array, struct, vector ;
initialize with parentheses () for class object constructor ;
default member initialization (in-class initializer) should not use parentheses () ;


---









































---


  </textarea>

</body>

</html>
