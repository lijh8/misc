mojo lang


---


Install

https://docs.modular.com/mojo/manual/get-started ,

install pixi first
$ curl -fsSL https://pixi.sh/install.sh | sh
The 'pixi' binary is installed into '/Users/ljh/.pixi/bin'
Updating '/Users/ljh/.zshrc'
Please restart or source your shell.
$

Then restart your terminal for the changes to take effect.

Navigate to the directory in which you want to create the project and execute:

$ pixi init hello \
  -c https://conda.modular.com/max-nightly/ -c conda-forge \
  && cd hello
$

Install the Modular Platform from the modular package (which includes Mojo):
$ pixi add mojo

checking the version of Mojo:
$ pixi run mojo --version

Start the virtual environment:
$ pixi shell

$ vi hello.mojo
$ mojo hello.mojo

$ mojo build hello.mojo

$ ./hello

To deactivate your virtual environment:
$ exit


Uninstall

$ pixi remove modular


---


vscode

extension: mojo by Modular,

1. open the mojo source code file with main entry function as current file /
    then press F5 to start debugging;
2. or, activity bar / run and debug / create a launch.json file / Mojo:
    .vscode/launch.json;

when accept input, use internal terminal instead of debug console.
launch.json:
    "runInTerminal": true,

this is similar to golang extension:
    "console": "integratedTerminal",

When install mojo extension in vscode, it will also install MAX SDK from Modular.
It seems taht this is not required for build and run mojo at command terminal.


---


https://docs.modular.com/mojo/manual/values/value-semantics#intro-to-value-semantics ,

// assignment is copy by value semantic.

sharing a value-semantic type means that you create a copy of the value.
This is also known as "pass by value."

def main():
    var x = 1
    var y = x
    y += 1

    print("x:", x)
    print("y:", y)

# OUTPUT
# x: 1
# y: 2

We assigned the value of x to y, which creates the value for y by
making a copy of x. When we increment y, the value of x doesn't change.
Each variable has exclusive ownership of a value.

Whereas, if a type instead uses reference semantics,
then y would point to the same value as x, and incrementing either one would
affect the value for both. Neither x nor y would "own" the value,
and any variable would be allowed to reference it and mutate it.

Numeric values in Mojo are value semantic because they're trivial types,
which are cheap to copy.


---


https://docs.modular.com/mojo/manual/values/value-semantics#value-semantics-in-mojo-functions ,

// function argument pass by reference semantic.

Value semantics also apply to function arguments in Mojo by default.
in the following function, the y argument is immutable by default,
so if the function wants to modify the value in the local scope,
it needs to make a local copy:

fn add_two(y: Int):
    # y += 2  # This would cause a compiler error because `y` is immutable
    # We can instead make an explicit copy:
    var z = y
    z += 2
    print("z:", z)

def main():
    var x = 1
    add_two(x)
    print("x:", x)

# OUTPUT
# z: 3
# x: 1

Thus, the default behavior for function arguments is fully value semantic:
arguments are immutable references,
and any living variable from the callee is not affected by the function.


---


from memory import ArcPointer

@fieldwise_init
struct T(Copyable, Movable):
    fn __init__(out self, value: Int, num: Int):
        self.ptr = ArcPointer(value)
        self.num = num

    fn __copyinit__(out self, existing: Self):
        self.ptr = existing.ptr
        self.num = existing.num

    fn __moveinit__(out self, owned existing: Self):
        self.ptr = existing.ptr^
        self.num = existing.num

    var ptr: ArcPointer[Int]
    var num: Int


def main():
    var x = T(10, 20)
    var y = x
    y.ptr[] += 1
    y.num += 1

    print("x.ptr:", x.ptr[], x.num, x.ptr.unsafe_ptr())
    print("y.ptr:", y.ptr[], y.num, y.ptr.unsafe_ptr())

# OUTPUT
# x.ptr: 11 20 0x511c3fe00008
# y.ptr: 11 21 0x511c3fe00008

// reference and share value by pointer member.
// but member of numeric is still value semantic.


---


https://docs.modular.com/mojo/manual/types ,

Most of the types are nominal types, defined by a struct.

There are some types that aren't defined as structs: Functions, NoneType.

These standard types aren't privileged.
Each of the standard library types is defined just like user-defined types—
even basic types like Int and String.


---


// like c++ class with virtual function
https://docs.modular.com/mojo/manual/traits/#using-traits ,

Traits solve this problem by letting you define a shared set of behaviors that
types can implement.

Then you can write a function that depends on the trait, rather than individual
types.


// like c++ template
https://docs.modular.com/mojo/manual/traits/#generic-structs-with-traits ,
You can also use traits when defining a generic container.
A generic container is a container (for example, an array or hashmap) that can
hold different data types.


---


https://docs.modular.com/mojo/manual/lifecycle/life#constructors-and-implicit-conversion ,

Implicit conversion can happen when one of the following occurs:
You assign a value of one type to a variable with a different type.
You pass a value of one type to a function that requires a different type.
You return a value of one type from a function that specifies a different return
type.


---


// __init__:
//      create a new instance not from another existing instance;
//
// __copyinit__, __moveinit__:
//      create a new instance from another existing instance;
//      assignment;
//      function argument passing;

// mojo use init for both creating an instance with initialization,
//   and assignment.
// it does not need separate assignment operator methods like c++.

https://docs.modular.com/mojo/manual/structs ,

So here it is with a constructor to initialize the two fields,
The __init__() method is one of many special methods
(also known as "dunder methods" because they have double underscores) with
pre-determined names.

Once you have a constructor, you can create an instance of MyPair and set the
fields.


https://docs.modular.com/mojo/manual/lifecycle/life#copy-constructor ,
When Mojo encounters an assignment statement that doesn't use the transfer
sigil (^),

it tries to make a copy of the right-side value by calling upon that type's
copy constructor,

Mojo also calls upon the copy constructor when a value is passed to a function
that takes the argument as owned

and when the lifetime of the given value does not end at that point.

If the lifetime of the value does end there (usually indicated with the
transfer sigil ^),
then Mojo instead invokes the move constructor.


---


https://docs.modular.com/mojo/manual/lifecycle/life#move-constructor ,
the only catch is that you must use the ^ transfer sigil to end the lifetime of
a move-only type
when assigning it to a new variable or when passing it as an owned argument.


---


https://docs.modular.com/mojo/manual/lifecycle/life#value-decorator ,
even if it's not used with self.name = name^, the Mojo compiler will notice
that name is last used here and convert this assignment into a move,
instead of a copy+delete.


---



// file handle, network and database connection, are non-memory (eg. variables)
//   resources.
// it is like using a custom deleter with c++ smart pointer.
https://docs.modular.com/mojo/manual/errors#use-a-context-manager ,
A context manager is an object that manages resources such as files,
network connections, and database connections.


---


https://docs.modular.com/mojo/manual/packages#mojo-modules ,
import MyPair into a file named main.mojo that's
in the same directory as mymodule.mojo:

  from mymodule import MyPair

it only works when mymodule.mojo is in the same directory as main.mojo.
Currently, you can't import .mojo files as modules if they reside in other
directories.
That is, unless you treat the directory as a Mojo package, as described in the
next section.


---


https://docs.modular.com/mojo/manual/pointers/ ,

Pointer,        C++ std::weak_ptr;
OwnedPointer,   C++ std::unique_ptr;
ArcPointer,     C++ std::shared_ptr;
UnsafePointer,  C, C++ low-level raw pointer, char *p1, int *p2, void *p3;

Using UnsafePointer:
- Building array-like structure, such as List;
- Interacting with external libraries including C++;


https://docs.modular.com/mojo/manual/pointers/unsafe-pointers#dereferencing-pointers ,

ptr[] = newValue

https://docs.modular.com/mojo/manual/functions/#variadic-keyword-arguments ,
https://docs.python.org/3/tutorial/controlflow.html#unpacking-argument-lists ,

mojo use the square bracket operator ptr[] for dereferencing pointer,
it is unlike c,c++.
because the star operator *ptr is used for unpack in python and mojo.


---


https://docs.modular.com/mojo/changelog#v244-2024-06-07 ,
```
v24.4, 2024-06-07:
Added a new Span type for taking slices of contiguous collections. (PR 595)
```

https://github.com/modular/modular/pull/2595 ,
Another motivation for this change is to reduce unnecessary copies on methods
such as slicing a List, which currently allocates a new list.
Ideally, we would just return a Span without making a copy.


---


https://docs.modular.com/mojo/manual/types ,

At compile time, the literal types are arbitrary-precision (also called
infinite-precision) values, so the compiler can perform compile-time
calculations without overflow or rounding errors.

At runtime the values are converted to finite-precision types—Int for integer
values, and Float64 for floating-point values. (This process of converting a
value that can only exist at compile time into a runtime value is called
materialization.)


---


https://docs.modular.com/mojo/changelog#v255-2025-08-05 ,

alias comptime_string = String("foo" + "bar")  # .unsafe_ptr()
var runtime_string = comptime_string


---


struct T:
    var name: String

    fn __init__(out self, name: String):
        self.name = name
        print("init", self.name)

    fn __copyinit__(out self, existing: Self):
        self.name = existing.name
        print("copyinit", self.name)

    fn __moveinit__(out self, owned existing: Self):
        self.name = existing.name
        print("moveinit", self.name)

    fn __del__(owned self):
        print("del", self.name)


fn f1(t: T):
    print("f1")


fn f2(owned t: T):
    print("f2")


fn main() raises:
    a = T("a")  # init, create new instance
    b = a  # copy
    c = a^  # move
    a = c  # copy, assignment

    # ref
    f1(a)
    f1(a)

    # copy
    f2(a)
    f2(a)

    # move
    # f2(a^)
    # f2(a^)

    #
    f1(b)
    f1(c)


'''

# OUTPUT

init a
copyinit a
moveinit a
copyinit a
f1
f1
copyinit a
del a
f2
del a
f2
f1
del a
f1
del a

'''


---


https://docs.modular.com/mojo/manual/packages ,
https://docs.modular.com/mojo/cli/run ,

1. a module is a file, a file is a module,
    module name is basename of the file without suffix extension;

2. the init file is required in mojo `__init__.mojo`,
    the __init__.py is not required in namespace package in python;

3. specify the parent dir with `mojo build -I <dir>`
    to foo_dir in import statement like `from foo_dir import foo_module`:

    $ mojo build -I <dir>
    $ mojo run   -I <dir>

    which is similar to:
    $ PYTHONPATH=<dir> python3 main.py


$ pwd
/home/ljh/Documents/hello_mojo/foo/src
$ ls
foo_dir  main
$ tree
.
├── foo_dir
│   ├── foo_module.mojo
│   └── __init__.mojo
└── main
    └── main.mojo

$
$ cat foo_dir/foo_module.mojo
def foo_fun():
    print("foo")
$
$ cat foo_dir/__init__.mojo
$
$ cat main/main.mojo
from foo_dir import foo_module
def main():
    print("main")
    foo_module.foo_fun()
$
$ pixi run mojo run -I . main/main.mojo
main
foo
$
$ cd main/
$ pixi run mojo run -I .. main.mojo
main
foo
$


---
