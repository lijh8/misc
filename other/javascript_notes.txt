
javascript notes


https://code.visualstudio.com/docs/languages/javascript#_debugging ,

Debug client side

You can debug your client-side code using a browser debugger such as our
built-in debugger for Edge and Chrome, or the Debugger for Firefox.


---


https://developer.mozilla.org/zh-CN/docs/Web/HTML/How_to/Add_JavaScript_to_your_web_page ,

在 HTML 中调用 JavaScript 代码，需要使用 <script> 元素。
使用 script 有两种方法：链接到外部脚本，在 HTML 中撰写 JavaScript。

    $ cat index.html
    <script src="path/to/my/script.js"></script>

    <script>
        window.addEventListener("load", () => {
            console.log("一旦页面完全加载完毕，此函数就会执行一次。");
        });
    </script>
    $

    $ cat script.js
        console.log('hello');
    $


---


    // example 1

    // 总是使用 === 进行相等比较，如果类型不一致，直接返回false
    // == 会转换类型，。

    let a = 10;
    let b; // = undefined;
    let c = null;

    a === 10 && console.log(typeof (a), a);
    b === undefined && console.log(typeof (b), b);
    c === null && console.log(typeof (c), c);


    // example 2

    // python tuple
    return (a.name, a.age, a.grade) == (b.name, b.age, b.grade);

    // 1. javascript Array every
    return ['name', 'age', 'grade'].every(prop => a[prop] === b[prop]);

    // 2. javascript for of
    for (const prop of ['name', 'age', 'grade']) {
        if (a[prop] !== b[prop]) return false;
    }
    return true;

    // 3. javascript
    return a.name === b.name &&
        a.age === b.age &&
        a.grade === b.grade;


---


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types ,

如果一条语句独占一行的话，那么分号是可以省略的。
但如果一行中有多条语句，那么这些语句必须用分号进行分隔。

在一条语句的末尾总是加上分号被认为是最佳实践，即使是在非严格需要的时候。
这个习惯可以大大减少代码出问题的可能性。

JavaScript 过去允许给未声明的变量赋值，而这会创建一个**未声明的全局**变量。
这在严格模式下是一个错误，应该彻底避免使用它。

当你在函数的外部声明变量时，该变量被称作全局变量。
let 和 const 声明也会被限制在声明所在的块语句中。
用 var 创建的变量不是块级作用域的，而只是块所在的*函数（或全局作用域）*的。

const 仅阻止重新赋值，而不阻止修改。被赋值为常量的对象的属性是不受保护的。
同样的，数组的元素也是不受保护的。


---


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration ,

for...in 遍历数组下标，或对象属性名。
for...of 遍历数组元素。


---


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Functions ,

参数本质上是按值传递给函数的——因此，即使函数体的代码为传递给函数的参数赋了新值，
这个改变也不会反映到全局或调用该函数的代码中。
如果你将对象作为参数传递，而函数改变了这个对象的属性，这样的改变对函数外部是可见的，
如果你将数组作为参数传递，而函数改变了这个数组的值，这样的改变对函数外部也同样可见，

可以在一个函数里面嵌套另外一个函数。嵌套（内部）函数对其容器（外部）函数是私有的。
它可以访问外部函数的参数和变量。

一个闭包必须保存它可见作用域中所有参数和变量。因为每一次调用传入的参数都可能不同，
每一次对外部函数的调用实际上重新创建了一遍这个闭包。
没有再被引用时，内存才会被释放。

闭包是 JavaScript 中最强大的特性之一。JavaScript 允许函数嵌套，
并且内部函数具有定义在外部函数中的所有变量和函数（以及外部函数能访问的所有变量和函数）
的完全访问权限。

由于内部函数可以访问外部函数的作用域，因此当内部函数生存周期大于外部函数时，
外部函数中定义的变量和函数的生存周期将比内部函数执行的持续时间要长。
当内部函数以某一种方式被任何一个外部函数之外的任何作用域访问时，就会创建闭包。

有两个因素会影响对箭头函数的引入：更简洁的函数和 this 的无绑定性。

箭头函数表达式（也称胖箭头，以区分未来 JavaScript 中假设的 -> 语法）
相比函数表达式具有较短的语法且没有它自己的 this、arguments、super 和 new.target。
箭头函数总是匿名的。

箭头函数没有自己的 this，而是使用封闭执行上下文的 this 值。


---


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_objects ,

JavaScript 的设计是一个简单的基于对象的范式。
一个对象就是一系列属性的集合，一个属性包含一个名和一个值。
一个属性的值可以是函数，这种情况下属性也被称为方法。

一个对象的属性可以被解释成一个附加到对象上的变量。
对象的属性和普通的 javascript 变量基本没什么区别，仅仅是属性属于某个对象。属性定义了对象的特征。
可以通过点符号来访问一个对象的属性。

可以在定义一个属性的时候就给它赋值。

// 动态添加属性和值。

    class A {
        a = 10;
        b;
        constructor(c) {
            this.b = 20;
            this.c = c;
        }
    };
    c = 30;
    a = new A(c);
    a.d = 40; // 动态添加属性和值
    console.log(a) // A {a: 10, b: 20, c: 30, d: 40}

对象的属性也可以通过方括号访问或者设置。
对象有时也被叫作关联数组，因为每个属性都有一个用于访问它的字符串值。
一个对象的属性名可以是任何有效的 JavaScript 字符串。
方括号中的所有键都将转换为字符串类型，因为 JavaScript 中的对象只能使用 String 类型作为键类型。
你也可以通过存储在变量中的字符串来访问属性。
通过使用 this 将传入函数的值赋给对象的属性。
对象增加新的属性。

myObj.type              = "Dot syntax";
myObj["date created"]   = "String with space";
myObj[str]              = "String value";

从 JavaScript 1.2 之后，你可以通过对象初始化器（Object Initializer）创建对象。
或者你可以创建一个构造函数并使用该函数和 new 操作符初始化对象。

使用对象初始化器也被称作通过字面值创建对象。

一个方法 是关联到某个对象的函数，或者简单地说，一个方法是一个值为某个函数的对象属性。
定义方法就像定义普通的函数，除了它们必须被赋给对象的某个属性。

通过 this 引用对象
JavaScript 有一个特殊的关键字 this，它可以在方法中使用以指代当前对象。


---


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_classes ,

    // 类
    class A {
        num = 10;
        num2;
        constructor() {
            this.num2 = 20;
        }
        f() {
            let num3 = 30;
            console.log(this.num);
            console.log(this.num2);
            console.log(num3);
        }
    };
    const a = new A();
    a.f();


    // 对象字面值
    const a2 = {
        num: 10,
        f() {
            let num2 = 30;
            console.log(this.num);
            console.log(num2);
        },
    };
    a2.f();


---


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Language_overview ,

可以将 JavaScript 对象当作是键值对的集合。

类似于：Python 中的字典。

对象总是引用，所以除非显式地复制对象，否则改变对象将会对外部可见。

这也意味着分别创建的两个对象永不可能相等（!==），因为它们是不同的引用。
如果你有同一个对象的两个引用，修改其中一个将能通过另一个观察到。

越界索引不会抛出异常。如果你查询的是不存在数组索引，你得到的返回值是 undefined。


---


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Data_structures ,

除了 Object 以外，所有的类型都定义了不可变的、在语言最底层直接表示的值。

// 不可变意思是：
// string，number，等，原始内置类型之间的赋值是拷贝语义，修改其中一个不会影响另一个。

undefined 表示值缺失，null 表示对象缺失。





---


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Closures ,

嵌套函数能访问在其外部作用域中声明的变量。
// 内层函数访问外层函数中的变量和参数。

    function init() {
    var name = "Mozilla"; // name 是 init 创建的局部变量
    function displayName() {
        // displayName() 是内部函数，它创建了一个闭包
        console.log(name); // 使用在父函数中声明的变量
    }
    displayName();
    }
    init();


let 和 const 的作用域

一直以来（ES 6 之前），JavaScript 变量仅有两种类型的作用域：函数作用域和全局作用域。
用 var 声明的变量要么属于函数作用域要么属于全局作用域，
这取决于变量是在函数内声明的还是在函数外声明的。花括号块不为 var 创建作用域。

在 ES 6 中，JavaScript 引入了 let 和 const 声明，
这些声明围绕在诸如暂时性死区的其他东西之中，会创建块级作用域的变量。

闭包是由函数以及函数声明所在的词法环境组合而成的。
该环境包含了这个闭包创建时作用域内的任何局部变量。


在循环中创建闭包：一个常见错误

循环遍历这些定义，将 onfocus 事件与显示帮助信息的方法进行关联。

如果你试着运行这段代码，你会发现它没有达到预期的效果。
无论你聚焦在那个字段上，显示的都是关于年龄的信息。

原因是赋值给 onfocus 的函数创建了闭包。
这些闭包是由函数定义和从 setupHelp 函数作用域中捕获的环境所组成的。这三个闭包在循环中创建，
但每个都共享同一个词法环境，这个环境有一个不断改变值的变量（item）。
这是因为 item 变量用 var 声明，并由于声明提升，因此拥有函数作用域。
而 item.help 的值是在 onfocus 回调执行时决定。因为循环在事件触发之前早已执行完毕，
所以 item 变量对象（由三个闭包共享）已经指向了 helpText 的最后一项。

    for (var i = 0; i < helpText.length; i++) {
        // 罪魁祸首是在这一行使用的 `var`
        var item = helpText[i];
        document.getElementById(item.id).onfocus = function () {
            showHelp(item.help);
        };
    }

这个例子的一个解决方案就是使用更多的闭包：特别是使用前面所述的函数工厂。
另一种方法是使用匿名闭包。

如果你不想使用过多的闭包，你可以使用 let 或 const 关键词。
这个示例使用 const 而不是 var，因此每个闭包绑定的是块作用域变量，这意味着不再需要额外的闭包。

    for (let i = 0; i < helpText.length; i++) {
        const item = helpText[i];
        document.getElementById(item.id).onfocus = () => {
            showHelp(item.help);
        };
    }


---


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Memory_management ,

内存管理

引用计数垃圾回收

创建了两个对象，一个对象的属性引用另一个对象，形成了一个循环。
引用计数算法不会认为它们可以被回收，因为每个对象至少还有一个指向自己的引用，
这样的结果就是它们两个都不会被标记为可以被垃圾回收。循环引用是内存泄露的常见原因。
现代 JavaScript 引擎不再使用引用计数进行垃圾回收。

    // 循环引用
    function f() {
        const x = {};
        const y = {};
        x.a = y; // x 引用 y
        y.a = x; // y 引用 x
        return "azerty";
    }
    f();


标记清除算法

这个算法将“对象不再需要”这个定义简化为“对象不可达”。
这个算法假定有一组叫做根的对象。在 JavaScript 中，根是全局对象。垃圾回收器将定期从这些根开始，
找到从这些根能引用到的所有对象，然后找到从这些对象能引用到的所有对象，等等。
从根开始，垃圾回收器将找到所有可到达的对象并收集所有不能到达的对象。

这个方法的直接好处就是循环不再是一个问题。在上面的示例中，在函数调用返回之后，
从全局对象可达的任何资源都将不再引用这两个对象。
因此，垃圾回收器会认为它们不可达并回收为它们分配的内存。


---
