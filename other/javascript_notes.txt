
javascript notes


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Grammar_and_types ,

如果一条语句独占一行的话，那么分号是可以省略的。
但如果一行中有多条语句，那么这些语句必须用分号进行分隔。

在一条语句的末尾总是加上分号被认为是最佳实践，即使是在非严格需要的时候。
这个习惯可以大大减少代码出问题的可能性。

JavaScript 过去允许给未声明的变量赋值，而这会创建一个**未声明的全局**变量。
这在严格模式下是一个错误，应该彻底避免使用它。

当你在函数的外部声明变量时，该变量被称作全局变量。
let 和 const 声明也会被限制在声明所在的块语句中。
用 var 创建的变量不是块级作用域的，而只是块所在的*函数（或全局作用域）*的。
let x = 42 等价于 let x; x = 42。

const 仅阻止重新赋值，而不阻止修改。被赋值为常量的对象的属性是不受保护的。
(const only prevents re-assignments, but doesn't prevent mutations)

同样的，数组的元素也是不受保护的。


---


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Loops_and_iteration ,

for...in 遍历数组下标，或对象属性名。
for...of 遍历数组元素。


---


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Functions ,

显然，函数本身就是对象，因此这些对象也有方法，

参数本质上是按值传递给函数的——因此，即使函数体的代码为传递给函数的参数赋了新值，

在下面的示例中，如果调用函数时没有给 b 提供值，那么它的值就是 undefined，
// 调用函数时实参个数可以少于形参个数，没传的参数初始化为 undefined。
// 调用函数时实参个数可以多于形参个数，多余的参数可以通过 arguments 访问。

这个改变也不会反映到全局或调用该函数的代码中。
如果你将对象作为参数传递，而函数改变了这个对象的属性，这样的改变对函数外部是可见的，
如果你将数组作为参数传递，而函数改变了这个数组的值，这样的改变对函数外部也同样可见，

可以在一个函数里面嵌套另外一个函数。嵌套（内部）函数对其容器（外部）函数是私有的。
它可以访问外部函数的参数和变量。

一个闭包必须保存它可见作用域中所有参数和变量。因为每一次调用传入的参数都可能不同，
每一次对外部函数的调用实际上重新创建了一遍这个闭包。
没有再被引用时，内存才会被释放。

闭包是 JavaScript 中最强大的特性之一。JavaScript 允许函数嵌套，
并且内部函数具有定义在外部函数中的所有变量和函数（以及外部函数能访问的所有变量和函数）
的完全访问权限。

由于内部函数可以访问外部函数的作用域，因此当内部函数生存周期大于外部函数时，
外部函数中定义的变量和函数的生存周期将比内部函数执行的持续时间要长。
当内部函数以某一种方式被任何一个外部函数之外的任何作用域访问时，就会创建闭包。

有两个因素会影响对箭头函数的引入：更简洁的函数和 this 的无绑定性。

箭头函数表达式（也称胖箭头，以区分未来 JavaScript 中假设的 -> 语法）
相比函数表达式具有较短的语法且没有它自己的 this、arguments、super 和 new.target。
箭头函数总是匿名的。

箭头函数没有自己的 this，而是使用封闭执行上下文的 this 值。
因此，在以下代码中，传递到 setInterval 中的函数内的 this 与闭包函数中的 this 相同：

    function Person() {
        this.age = 0;

        setInterval(() => {
                this.age++; // 这里的 `this` 正确地指向 person 对象
        }, 1000);
    }

const p = new Person();


---


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Working_with_objects ,

一个对象就是一系列属性的集合，一个属性包含一个名和一个值。
一个属性的值可以是函数，这种情况下属性也被称为方法。

对象中未赋值的属性的值为undefined（而不是null）。

    // undefined 指未初始化的变量
    let foo; // = 3.14;

    // null用来置空清理变量
    let foo = null;

一个对象的属性可以被解释成一个附加到对象上的变量。
对象的属性和普通的 javascript 变量基本没什么区别，仅仅是属性属于某个对象。属性定义了对象的特征。
可以通过点符号来访问一个对象的属性。

可以在定义一个属性的时候就给它赋值。


    // 使用 class 关键字
    class A {
        a = 10;
        b; // = undefined;
        constructor(c) {
            this.b = 20;
            this.c = c;
        }
    };
    let c = 30;
    const a = new A(c);
    a.d = 40; // 动态添加属性
    console.log(a) // A {a: 10, b: 20, c: 30, d: 40}

    // 使用对象字面值
    const obj = {
        a: 10,
        b: undefined,
        f(c) {
            this.b = 20;
            this.c = c;
        },
    };
    let c2 = 30;
    obj.f(c2);
    obj.d = 40; // 动态添加属性
    console.log(obj) // A {a: 10, b: 20, c: 30, d: 40}


对象的属性也可以通过方括号访问或者设置。
对象有时也被叫作关联数组，因为每个属性都有一个用于访问它的字符串值。
一个对象的属性名可以是任何有效的 JavaScript 字符串。
方括号中的所有键都将转换为字符串类型，因为 JavaScript 中的对象只能使用 String 类型作为键类型。
你也可以通过存储在变量中的字符串来访问属性。
通过使用 this 将传入函数的值赋给对象的属性。
对象增加新的属性。

    myObj.type              = "Dot syntax";
    myObj["date created"]   = "String with space";
    myObj[str]              = "String value";

从 JavaScript 1.2 之后，你可以通过对象初始化器（Object Initializer）创建对象。
或者你可以创建一个构造函数并使用该函数和 new 操作符初始化对象。

使用对象初始化器也被称作通过字面值创建对象。

一个方法 是关联到某个对象的函数，或者简单地说，一个方法是一个值为某个函数的对象属性。
定义方法就像定义普通的函数，除了它们必须被赋给对象的某个属性。

定义方法
一个方法 是关联到某个对象的函数，或者简单地说，一个方法是一个值为某个函数的对象属性。
定义方法就像定义普通的函数，除了它们必须被赋给对象的某个属性。

    var myObj = {
            myMethod: function(params) {
                // ...do something
            }

            // 或者 这样写也可以
            myOtherMethod(params) {
                // ...do something else
            }
    };


通过 this 引用对象
JavaScript 有一个特殊的关键字 this，它可以在方法中使用以指代当前对象。


---


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Using_classes ,

大多数 JavaScript 纯函数都可用作构造函数，

如果你用过早于 ES6 的版本，你可能更熟悉使用函数作为构造函数。

典型函数构造器可以使用 new 来构造，也可以不使用 new 来调用。
然而，对于类的“调用”则必须使用 new，否则会导致错误。

this 的值将自动作为 new 的结果返回。
不建议从构造函数中返回任何值——因为如果你返回一个非原始类型的值，
它将成为 new 表达式的值，而 this 的值将被丢弃。

super() 调用父类的构造函数来初始化 this,


类通常通过类声明来创建。

    class MyClass {
        // 构造函数
        constructor() {
        }
        // 实例字段
        myField = "foo";
        // 实例方法
        myMethod() {
        }
        // 静态字段
        static myStaticField = "bar";
        // 静态方法
        static myStaticMethod() {
        }
        // 静态块
        static {
            // 静态初始化代码
        }
        // 字段、方法、静态字段、静态方法、静态块都可以使用“私有”形式
        #myPrivateField = "bar";
    }

在声明一个类之后，你可以使用 new 运算符来创建它的实例。

    const myInstance = new MyClass();
    console.log(myInstance.myField); // 'foo'
    myInstance.myMethod();


---


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Language_overview ,

可以将 JavaScript 对象当作是键值对的集合。

类似于：Python 中的字典。

对象总是引用，所以除非显式地复制对象，否则改变对象将会对外部可见。

这也意味着分别创建的两个对象永不可能相等（!==），因为它们是不同的引用。
如果你有同一个对象的两个引用，修改其中一个将能通过另一个观察到。

越界索引不会抛出异常。如果你查询的是不存在数组索引，你得到的返回值是 undefined。


---


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Data_structures ,

除了 Object 以外，所有的类型都定义了不可变的、在语言最底层直接表示的值。

undefined 表示值缺失，null 表示对象缺失。


---


不可变是指：

- 基本类型之间的赋值是拷贝语义，修改其中一个不会影响另一个。
- 不能引用并修改其属性，比如修改String内的字符元素。

对象类型是可变的，对象是引用类型。

const 仅阻止重新赋值，而不阻止修改。

字符串是不可变，如要修改其中的字符元素，可以转换为数组，修改数组元素，再转回字符串。

    let s = 'abc';
    const a = [...s];
    a[0] = 'A';
    s = a.join('');
    console.log(s); // 'Abc'


---


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Equality_comparisons_and_sameness ,

使用 === 进行严格相等比较，使用严格相等几乎总是正确的选择。


---


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Closures ,

嵌套函数能访问在其外部作用域中声明的变量。
// 内层函数访问外层函数中的变量和参数。

    function init() {
    var name = "Mozilla"; // name 是 init 创建的局部变量
    function displayName() {
        // displayName() 是内部函数，它创建了一个闭包
        console.log(name); // 使用在父函数中声明的变量
    }
    displayName();
    }
    init();


let 和 const 的作用域

一直以来（ES 6 之前），JavaScript 变量仅有两种类型的作用域：函数作用域和全局作用域。
用 var 声明的变量要么属于函数作用域要么属于全局作用域，
这取决于变量是在函数内声明的还是在函数外声明的。花括号块不为 var 创建作用域。

在 ES 6 中，JavaScript 引入了 let 和 const 声明，
这些声明围绕在诸如暂时性死区的其他东西之中，会创建块级作用域的变量。

闭包是由函数以及函数声明所在的词法环境组合而成的。
该环境包含了这个闭包创建时作用域内的任何局部变量。


在循环中创建闭包：一个常见错误

循环遍历这些定义，将 onfocus 事件与显示帮助信息的方法进行关联。

如果你试着运行这段代码，你会发现它没有达到预期的效果。
无论你聚焦在那个字段上，显示的都是关于年龄的信息。

原因是赋值给 onfocus 的函数创建了闭包。
这些闭包是由函数定义和从 setupHelp 函数作用域中捕获的环境所组成的。这三个闭包在循环中创建，
但每个都共享同一个词法环境，这个环境有一个不断改变值的变量（item）。
这是因为 item 变量用 var 声明，并由于声明提升，因此拥有函数作用域。
而 item.help 的值是在 onfocus 回调执行时决定。因为循环在事件触发之前早已执行完毕，
所以 item 变量对象（由三个闭包共享）已经指向了 helpText 的最后一项。

    for (var i = 0; i < helpText.length; i++) {
        // 罪魁祸首是在这一行使用的 `var`
        var item = helpText[i];
        document.getElementById(item.id).onfocus = function () {
            showHelp(item.help);
        };
    }

这个例子的一个解决方案就是使用更多的闭包：特别是使用前面所述的函数工厂。
另一种方法是使用匿名闭包。

如果你不想使用过多的闭包，你可以使用 let 或 const 关键词。
这个示例使用 const 而不是 var，因此每个闭包绑定的是块作用域变量，这意味着不再需要额外的闭包。

    for (let i = 0; i < helpText.length; i++) {
        const item = helpText[i];
        document.getElementById(item.id).onfocus = () => {
            showHelp(item.help);
        };
    }


---


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Memory_management ,

内存管理

引用计数垃圾回收

创建了两个对象，一个对象的属性引用另一个对象，形成了一个循环。
引用计数算法不会认为它们可以被回收，因为每个对象至少还有一个指向自己的引用，
这样的结果就是它们两个都不会被标记为可以被垃圾回收。循环引用是内存泄露的常见原因。
现代 JavaScript 引擎不再使用引用计数进行垃圾回收。

    // 循环引用
    function f() {
        const x = {};
        const y = {};
        x.a = y; // x 引用 y
        y.a = x; // y 引用 x
        return "azerty";
    }
    f();


标记清除算法

这个算法将“对象不再需要”这个定义简化为“对象不可达”。
这个算法假定有一组叫做根的对象。在 JavaScript 中，根是全局对象。垃圾回收器将定期从这些根开始，
找到从这些根能引用到的所有对象，然后找到从这些对象能引用到的所有对象，等等。
从根开始，垃圾回收器将找到所有可到达的对象并收集所有不能到达的对象。

这个方法的直接好处就是循环不再是一个问题。在上面的示例中，在函数调用返回之后，
从全局对象可达的任何资源都将不再引用这两个对象。
因此，垃圾回收器会认为它们不可达并回收为它们分配的内存。


---


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions ,

箭头函数没有独立的 this、arguments 和 super 绑定，并且不可被用作方法。
箭头函数不能用作构造函数。使用 new 调用它们会引发 TypeError。它们也无法访问 new.target 关键字。
箭头函数不能在其主体中使用 yield，也不能作为生成器函数创建。

不能用作方法，
箭头函数表达式只能用于非方法函数，因为它们没有自己的 this。

由于类体具有 this 上下文，因此作为类字段的箭头函数会关闭类的 this 上下文，
箭头函数体中的 this 将正确指向实例（对于静态字段来说是类本身）。
但是，由于它是一个闭包，而不是函数本身的绑定，因此 this 的值不会根据执行上下文而改变。

箭头函数属性通常被称作“自动绑定方法”，因为它与普通方法的等价性相同，

类字段是在实例（instance）上定义的，而不是在原型（prototype）上定义的，
因此每次创建实例都会创建一个新的函数引用并分配一个新的闭包，
这可能会导致比普通非绑定方法更多的内存使用。

使用箭头函数的最大好处可能是在使用 setTimeout() 和
EventTarget.prototype.addEventListener() 等方法时，
这些方法通常需要某种闭包、call()、apply() 或 bind()，以确保函数在适当的作用域中执行。

    document.getElementById('button1').addEventListener('click', () => {
        const input = document.getElementById('input1').value;
        document.getElementById('label1').textContent = input;
    });

有了箭头函数，this 作用域更容易被保留。


---


在 JavaScript 中，箭头函数不能作为方法使用，尤其在对象字面量或 class 关键字声明类中需谨慎。

1. 箭头函数没有自己的 this，它会词法捕获外层作用域的 this。
    在对象字面量中定义时，this 通常指向全局对象（或模块顶层），无法访问该对象自身的属性。

    const person = {
        name: 'Alice',
        // 箭头函数：this 来自外层作用域（如全局）
        sayHelloArrow: () => {
            console.log(`Hello, ${this.name}`); // this 不是 person，输出 "Hello, undefined"
        },
        // 普通方法：this 动态绑定到调用对象
        sayHelloNormal() {
            console.log(`Hello, ${this.name}`); // 输出 "Hello, Alice"
        }
    };

    person.sayHelloArrow();   // "Hello, undefined"
    person.sayHelloNormal();  // "Hello, Alice"


2. 在 class 关键字声明类中使用箭头函数字段（如 say = () => {}）会在构造时绑定实例的 this，
    使其在作为回调传递时仍保持正确上下文。但这会绕过原型链，无法被子类通过 super 调用，
    也不支持动态 this 行为。

    class Person {
        constructor(name) {
            this.name = name;
        }
        // 箭头函数字段：this 固化为实例
        sayHelloArrow = () => console.log(`Hello, ${this.name}`);
        // 普通方法：this 动态绑定
        sayHelloNormal() { console.log(`Hello, ${this.name}`); }
    }

    const person = new Person('Bob');
    const arrow = person.sayHelloArrow;
    const normal = person.sayHelloNormal;

    arrow();   // "Hello, Bob"（this 仍指向 person）
    normal();  // "Hello, undefined"（this 丢失）


3. 普通函数的 this 在调用时动态确定，这是面向对象中方法复用和多态的基础。
    但一旦方法被提取为独立函数（如用作回调），this 就会丢失。
    此时应使用箭头函数或显式绑定（如 .bind()）来保持上下文。


4. 推荐使用箭头函数的场景：作为事件处理器、定时器回调等需要保持外层 this 的场合。
    不需要动态 this、也不作为可复用方法的函数。

    document.getElementById('button1').addEventListener('click', () => {
        const input = document.getElementById('input1').value;
        document.getElementById('label1').textContent = input;
    });


---


https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Core/Scripting/What_is_JavaScript ,

内联 JavaScript 处理器

在 <button> 元素中包含了一个内联的 onclick 处理器，使得函数在按钮被按下时运行。

    <button onclick="createParagraph()">点我！</button>

然而请不要这样做。这将使 JavaScript 污染了 HTML，而且效率低下。
对于每个需要应用 JavaScript 的按钮，你都得手动添加 onclick="createParagraph()" 属性。

脚本加载策略

页面上的所有 HTML 代码都按其出现的顺序加载。如果使用 JavaScript 去操作页面上的元素
（更准确的说，是文档对象模型），
那么如果 JavaScript 在 HTML 之前就被加载和解析了，代码将无法运行。

有几种不同的策略来确保 JavaScript 只在 HTML 解析之后运行：

在上面的内部 JavaScript 示例中，脚本元素放在文档正文的底部，
因此只能在 HTML 正文的其他部分被解析以后运行。

在上面的外部 JavaScript 实例中，脚本元素放在文档的头部，在解析 HTML 正文之前解析。
但是由于我们使用了 <script type="module">，代码被视为一个模块，
并且浏览器在执行 JavaScript 模块之前会等待所有的 HTML 代码都处理完毕
（也可以把外部脚本放在正文的底部，但是如果 HTML 内容较多且网络较慢，
在浏览器开始获取并加载脚本之前可能需要大量的时间，因此将外部脚本放在头部通常会更好一些）。

如果仍然想在文档头部使用非模块脚本，可能阻塞整个页面的显示，并且可能出现错误，
因为脚本在文档解析之前执行：

对于外部脚本，应该在 <script> 元素上添加 defer（或者如果不需要 HTML 解析完成，
则可以使用 async）属性。
对于内部脚本，应该将代码封装在 DOMContextLoaded 事件监听器中。

// 内部脚本放在 body 底部，即 </body> 结束标记之前。
// 外部脚本放在 head，需要用 defer，让 DOM 先解析完成。


---


https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Core/Scripting/Events ,

能够触发事件的对象有一个 addEventListener() 方法，这就是推荐的添加事件处理器的机制。

内联事件处理器——不要使用

    <button onclick="bgChange()">按下我</button>

作为一项安全措施，许多常见的服务器配置将禁止内联 JavaScript。
你永远不应该使用 HTML 事件处理器属性——那些已经过时了，使用它们是不好的做法。


---


https://developer.mozilla.org/zh-CN/docs/Learn_web_development/Core/Scripting/Object_basics ,

对象是一个包含相关数据和方法的集合（通常由一些变量和函数组成，我们称之为对象里面的属性和方法）
每一组名字/值必须由逗号分隔开，并且名字和值之间由冒号分隔，
当对象的成员是函数时，语法会更简单。我们可以写 bio() 来代替 bio: function()
对象字面量（object literal）——手动的写出对象的内容来创建一个对象。不同于从类实例化一个对象，
可以用一个对象来做另一个对象成员的值。
需要访问这些属性，只需要链式的再使用一次点表示法，

另外一种访问对象属性的方式是使用括号表示法（bracket notation），
这看起来很像访问一个数组的元素，并且基本上是相同的——使用关联了值的名称，而不是索引来选择元素。
因此对象有时被称为关联数组——对象将字符串映射到值，而数组将数字映射到值。
点表示法通常优于括号表示法，因为它更简洁且更易于阅读。然而，在某些情况下你必须使用括号。
例如，如果对象属性名称保存在变量中，则不能使用点表示法访问该值，但可以使用括号表示法访问该值。


---


https://code.visualstudio.com/docs/languages/javascript#_debugging ,

Debug client side

You can debug your client-side code using a browser debugger such as our
built-in debugger for Edge and Chrome, or the Debugger for Firefox.


---


https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive ,

在 JavaScript 中，原始值（原始数据类型）是一种既非对象也无方法或属性的数据。有 7 种原始数据类型：

    string
    number
    bigint
    boolean
    undefined
    symbol
    null

多数情况下，原始值直接代表了最底层的语言实现。

所有原始值都是不可变的，即它们的值不能被修改。重要的是不要将原始值本身与分配了原始值的变量混淆。
变量可能会被重新赋予一个新值，但存在的值不能像数组、对象以及函数那样被修改。
语言不提供改变原始值的工具方法。

基本类型没有方法，但仍然表现得像有方法一样。当在原始值上访问属性时，
JavaScript 自动将值装入包装对象中，并访问该对象上的属性。
例如，"foo".includes("f") 隐式创建了一个 String 包装对象，
并在该对象上调用 String.prototype.includes()。
这种自动装箱行为在 JavaScript 代码中是无法观察到的，但却是各种行为的一个很好的心理模型——例如，
为什么“修改”原始值不起作用（因为 str.foo = 1 不是赋值给 str 本身的 foo 属性，
而是赋值给了一个临时包装对象）。


---


https://developer.mozilla.org/zh-CN/docs/Glossary/IIFE ,

立即调用函数表达式 (IIFE)

函数表达式。其通常需要用括号括起来才能被正确解析。


    // 标准 IIFE
    (function () {
    // 语句……
    })();

    // 箭头函数变体
    (() => {
    // 语句……
    })();

    // 异步 IIFE
    (async () => {
    // 语句……
    })();


---


    // 总是使用 === 进行相等比较，如果类型不一致，直接返回false

    let a = 10;
    let b; // = undefined;
    let c = null;

    a === 10 && console.log(typeof (a), a);
    b === undefined && console.log(typeof (b), b);
    c === null && console.log(typeof (c), c);


---


    // python tuple
    // (a.name, a.age, a.grade) < (b.name, b.age, b.grade)
    // (a.name, a.age, a.grade) == (b.name, b.age, b.grade)

    // javascript
    function lessThan(a, b) {
        if (a.name !== b.name) return a.name < b.name;
        if (a.age !== b.age) return a.age < b.age;
        return a.grade < b.grade;
    }

    function equalTo(a, b) {
        return a.name === b.name &&
            a.age === b.age &&
            a.grade === b.grade;
    }

    // three way comparison
    function compare(a, b) {
        const keys = ['name', 'age', 'grade'];
        for (k of keys) {
            if (a[k] < b[k]) return -1;
            if (a[k] > b[k]) return 1;
        }
        return 0;
    }

    const persons = [
        { name: "alice", age: 7, grade: 3 },
        { name: "bob", age: 8, grade: 4 },
        { name: "charlie", age: 9, grade: 5 },
    ];

    console.log(lessThan(persons[0], persons[0]));
    console.log(equalTo(persons[0], persons[0]));

    console.log(lessThan(persons[0], persons[1]));
    console.log(equalTo(persons[0], persons[1]));

    console.log(lessThan(persons[1], persons[0]));
    console.log(equalTo(persons[1], persons[0]));

    console.log(compare(persons[0], persons[0]));
    console.log(compare(persons[0], persons[1]));
    console.log(compare(persons[1], persons[0]));


---


    /**
     * 使用快速排序算法对数组进行原地升序排序
     * @param {number[]} arr 要排序的数字数组。
     * @param {number} [left=0] 排序的起始索引。
     * @param {number} [right=arr.length - 1] 排序的结束索引。
     * @returns {number[]} 排序后的数组。
     *
     * @example
     * const nums = [3, 1, 4, 1, 5];
     * quickSort(nums);
     * console.log(nums); // [1, 1, 3, 4, 5]
     */
    function quickSort(arr, left = 0, right = arr.length - 1) {
        if (left >= right) return arr;
        const pivot = arr[Math.floor((left + right) / 2)];
        let i = left;
        let j = right;

        while (i <= j) {
            while (arr[i] < pivot) i++;
            while (arr[j] > pivot) j--;

            if (i <= j) {
                [arr[i], arr[j]] = [arr[j], arr[i]];
                i++;
                j--;
            }
        }

        quickSort(arr, left, j);
        quickSort(arr, i, right);
        return arr;
    }

    const arr = [
        [1, 2, 3, 1],
        [1, 3, 2, 1],
        [1, 2],
        [2, 1],
        [1],
        [],
    ];
    arr.forEach(e => quickSort(e));
    arr.forEach(e => console.log(e));


---


    // JavaScript 基于原型（prototype-based）
    // - 没有“类”这个必需概念（ES6 的 class 只是语法糖，底层仍是原型）。
    // - 对象可以直接创建（例如通过对象字面量 {}）。
    // - 对象可以有一个原型（prototype），当访问属性时，如果自身没有，就去原型链上查找。

    const animal = { eats: true };
    const rabbit = { jumps: true };
    rabbit.__proto__ = animal; // 原型链
    console.log(rabbit.eats); // true - 通过原型链找到


---


    // ES6 的 class 只是语法糖，底层还是原型
    class Animal {
        constructor() { this.eats = true; }
    }


---


    // 运行时可以动态修改对象
    const obj = { a: 1 };
    obj.b = 2; // 随时添加属性
    delete obj.a; // 随时删除属性
    // 对象可以随时改变类型
    obj.sayHello = function() { return "Hello!"; };


---


    // 直接创建对象，无需类
    const obj1 = {}; // 对象字面量
    const obj2 = new Object(); // 构造函数
    const obj3 = Object.create(null); // 指定原型
    const obj4 = Object.create(obj); // 基于原型继承


---


    // 函数也是对象
    function Person() {}
    Person.age = 30; // 给函数添加属性


---


    const person = {
        name: "John",
        greet() { console.log("Hello"); }
    };
    // 可以随时扩展
    person.sayGoodbye = function() { console.log("Bye"); };


---


    // 创建原型链
    const grandParent = { a: 1 };
    const parent = { b: 2 };
    const child = { c: 3 };

    // 构建原型链：child -> parent -> grandParent
    Object.setPrototypeOf(parent, grandParent);
    Object.setPrototypeOf(child, parent);

    // 查找过程演示
    console.log(child.c); // 3 - 自身属性，直接返回
    console.log(child.b); // 2 - 自身没有，去 parent 原型找到
    console.log(child.a); // 1 - 自身和parent都没有，去 grandParent 找到
    console.log(child.d); // undefined - 整条链都没有


---


https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise ,

Promise 并发

Promise 类提供了四个静态方法来促进异步任务的并发：
    Promise.all()
    Promise.allSettled()
    Promise.any()
    Promise.race()


<script>

    function sleep(ms) {
        // 实参可以多余或少于形参。
        // reject 参数没有传递。
        // 通过后续 .then(resolve, reject) 传递回调处理函数。
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    async function heavyTask(name) {
        const duration = 1000;
        console.log(`Task ${name} starting...`);
        await sleep(duration);
        console.log(`Task ${name} completed after ${duration}ms`);
        return `Result from ${name}`;
    }

    async function main() {
        const label = 'Total time'
        console.time(label);

        // Three tasks that each take 1 second
        const task1 = heavyTask('A');
        const task2 = heavyTask('B');
        const task3 = heavyTask('C');

        // Asynchronous tasks execute concurrently, so the total execution time
        // will be less than the sum of individual task times when executed sequentially.
        // The total time will be just slightly longer than the duration of the longest task.

        const results = await Promise.all([task1, task2, task3]);

        // Total time: 1001.70703125 ms,
        // which is less then sum of 3 seconds.
        console.timeEnd(label);
        console.log('All results:', results);
    }

    main();

</script>


---


// version 1:
// 自定义亮暗主题背景色和前景色。

<!DOCTYPE html>
<html>
<head>
    <meta name="color-scheme" content="light dark" />
    <title>page1</title>
    <style>
        /* 浅色主题默认属性 */
        :root {
            /* 通知浏览器支持浅色和深色主题 */
            color-scheme: light dark;
            --fg-color: #212529;
            --bg-color: #f8f9fa;
        }
        /* 切换深色主题时覆盖浅色属性 */
        @media (prefers-color-scheme: dark) {
            :root {
                --fg-color: #f8f9fa;
                --bg-color: #212529;
            }
        }
        body {
            /* 更柔和的前景和背景颜色 */
            color: var(--fg-color);
            background-color: var(--bg-color);

            /* 默认: 高对比度前景和背景颜色，纯黑和纯白 */
            /* color: CanvasText; */
            /* background-color: Canvas; */
        }
    </style>
</head>
<body>
    <input type="text" id="input1">
    <button id="button1">button</button>
    <label id="label1"></label>
    <script>
        document.getElementById('button1').addEventListener('click', function () {
            const input = document.getElementById('input1').value;
            document.getElementById('label1').textContent = input;
        });
    </script>
</body>

</html>


// version 2:
// 极简用法。可能背景色Canvas太暗，或者前景色CanvasText太亮。

<!DOCTYPE html>
<html>
<head>
    <meta name="color-scheme" content="light dark" />
    <title>page1</title>
    <style>
        :root {
            color-scheme: light dark;
        }
    </style>
</head>
<body>
    <input type="text" id="input1">
    <button id="button1">button</button>
    <label id="label1"></label>
    <script>
        document.getElementById('button1').addEventListener('click', function () {
            const input = document.getElementById('input1').value;
            document.getElementById('label1').textContent = input;
        });
    </script>
</body>
</html>


---


// 支持 svg 自定义绘图背景色及前景色

    <meta name="color-scheme" content="light dark" />
    <style>
        :root {
            color-scheme: light dark;
            --bg-color: #f8f9fa;
            --fg-color: #212529;
            --red-piece-color: #d32f2f;
            --path-color: #1565c0;
        }

        @media (prefers-color-scheme: dark) {
            :root {
                --bg-color: #212529;
                --fg-color: #f8f9fa;
                --red-piece-color: #ff5252;
                --path-color: #64b5f6;
            }
        }

        body {
            background-color: var(--bg-color);
            color: var(--fg-color);
        }
    </style>

    <script>
        function drawGrid() {
            riverLayer.appendChild(el('rect', {
                fill: 'var(--bg-color)'
            }));
        }
    </script>


---


<html>

<body>
    <input type="file" id="fileInput" />
    <button id="saveButton">保存文件</button>
    <pre id="output"></pre>
    <script>
        document.querySelector('#fileInput').addEventListener('change', function (event) {
            const file = event.target.files[0];
            const reader = new FileReader();
            reader.onload = function (e) {
                document.querySelector('#output').textContent = e.target.result;
            };
            reader.readAsText(file);
        });

        document.querySelector('#saveButton').addEventListener('click', function () {
            const hashes = Array.from({ length: 10 }, (_, i) =>
                Math.random().toString(36).substring(2) + i
            ).join('\n');

            const blob = new Blob([hashes], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'hashes.txt';
            a.click();
            URL.revokeObjectURL(url);
        });
    </script>
</body>

</html>


---


https://developer.mozilla.org/zh-CN/docs/Web/HTML/How_to/Add_JavaScript_to_your_web_page ,

在 HTML 中调用 JavaScript 代码，需要使用 <script> 元素。
使用 script 有两种方法：链接到外部脚本，在 HTML 中撰写 JavaScript。

    $ cat index.html
    <script src="path/to/my/script.js"></script>

    <script>
        window.addEventListener("load", () => {
            console.log("一旦页面完全加载完毕，此函数就会执行一次。");
        });
    </script>
    $

    $ cat script.js
        console.log('hello');
    $


---


使用 viewport，让 html 页面在小屏幕上不会被缩小。

    <meta name="viewport" content="width=device-width, initial-scale=1.0">


---


# 获取 body 样式
    window.getComputedStyle(document.body).getPropertyValue('background-color');
    window.getComputedStyle(document.body).backgroundColor

# 获取一个 button 样式
    const myButton = document.getElementById('myButton');
    window.getComputedStyle(myButton).backgroundColor

// https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement/style ,
This code example shows how you can read the inline styles of an element.
In each case it reads the dash-named style properties using getPropertyValue()
and gets the camel case properties using the dot operator.

    // html
    <div style="font-weight: bold;">
        <div style="border-top: 1px solid blue; color: red;" id="elt">
            An example div
        </div>
        <pre id="log"></pre>
    </div>

    // javascript
    const element = document.getElementById("elt");
    const elementStyle = element.style;

    // Longhand styles
    log(`"border-top" = '${elementStyle.getPropertyValue("border-top")}'`);
    log(`"borderTop" = '${elementStyle.borderTop}'`);


---


- 打开浏览器 Chrome DevTools Console 检查错误。
    F12,
    View / Developer / Javascript console

- 防止拼写错误导致全局污染。
    不使用 let, const, var 关键字，
    直接对一个不存在的变量赋值，非严格模式下会隐式自动创建全局变量。

    'use strict';
    let count = 0;
    counnt = 1; // 拼错了！非严格模式下会隐式自动创建全局变量 counnt

- 防止滥用异常。
    如果不确定如何处理，不要 catch，让错误冒泡到全局错误处理器。

- 防止“空的 catch 块” 或 “异常吞噬”（exception swallowing）
    永远不要写空的 catch 块，这是严重反模式。

    // 错误做法：空的 catch 块
    try {
        misTypedFunction(); // 拼写错误，会抛出 ReferenceError
    } catch (e) {
        // 空的 catch 块，啥也不干 → 错误被“吞掉”
    }

    // 正确做法：至少应该记录错误，或重新抛出原错误
    try {
        misTypedFunction(); // 拼写错误，会抛出 ReferenceError
    } catch (e) {
        console.error(e); // 记录错误
        throw e; // 重新抛出原错误
    }


---


$ ls
foo.html
$

# start web server in the directory of the html file:

$ python3 -m http.server 8000

$ ps -ef | grep -i python3
  501  1060  1045   0  9:36PM ttys001    0:00.93 python -m http.server 8000
$

$ ip addr | grep 192
192.168.1.3
$

# access html file in browser:

http://192.168.1.3:8000/foo.html


---


WebRTC - 实时视频传输
WebSocket - 控制信令传输
Canvas - 视频渲染和坐标映射
Mouse/Keyboard Events - 输入事件处理

WebRTC 支持的硬件：
    摄像头 - 通过 getUserMedia({ video: true })
    麦克风 - 通过 getUserMedia({ audio: true })
    扬声器/耳机 - 通过 <audio>/<video>元素输出
    屏幕共享 - 通过 getDisplayMedia()

WebRTC：
    点对点（P2P） 直接通信
    使用UDP，延迟更低
    适合音视频流、文件传输
    需要信令服务器（通常用WebSocket）来建立连接

WebSocket：
    客户端与服务器之间的双向通信
    基于TCP，有连接开销
    适合实时消息、聊天等场景
    需要中间服务器中转


---
