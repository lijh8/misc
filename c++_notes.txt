c, c++ notes

// variadic macro
// log with filename, line number source location

#define LOG(fmt, ...) printf("%s:%d: " fmt "\n", __FILE__, __LINE__, __VA_ARGS__)
LOG("%s", "");                          // portable
LOG("%s, %d, %f", "hello", 123, 3.14);  // portable

// GNU extension ##__VA_ARGS__
#define LOG(fmt, ...) printf("%s:%d: " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)
LOG();                                  // with GNU extension
LOG("");                                // with GNU extension

main.c:10:
main.c:12: hello, 123, 3.140000


---


Quick sort

1. It selects an element as a pivot (common strategies include the first, last,
    middle, or a random element).
2. It partitions the array so that:
    - Elements less than or equal to the pivot are swapped to its left.
    - Elements greater than the pivot are swapped to its right.
    - The pivot is placed in its final sorted position.
3. It recursively applies the same process to the left and right subarrays until
    the entire array is sorted.
4. Quicksort implementations often use in-place swaps instead of insertions or
    deletions.
5. Quick sort uses divide and conquer: each comparison eliminates many
    possibilities. Once a pivot is placed, elements on the left are known to be
    smaller than the pivot and elements on the right are known to be larger. No
    further comparisons cross these partitions.
6. In exhaustive brute force like selection sort: each pass reduces the number of
    comparisons for the next pass by only 1.


---


// K&R C 2nd, sec. 4.10 Recursion

void swap(int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

void qsort(int v[], int left, int right)
{
    int i, last;

    if (left >= right)
        return;
    swap(&v[left], &v[(left + right) / 2]);
    last = left;
    for (i = left + 1; i <= right; i++)
        if (v[i] < v[left])
            swap(&v[++last], &v[i]);
    swap(&v[left], &v[last]);
    qsort(v, left, last - 1);
    qsort(v, last + 1, right);
}


---


#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// places pivot in correct position and returns its index
int partition(int arr[], int low, int high)
{
    int random_idx = low + rand() % (high - low + 1);
    swap(&arr[random_idx], &arr[high]);

    int pivot = arr[high];
    int i = low - 1;

    for (int j = low; j < high; j++)
    {
        if (arr[j] <= pivot)
        {
            swap(&arr[++i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return i + 1;
}

void quickSort(int arr[], int low, int high)
{
    if (low < high)
    {
        // pi is partitioning index
        int pi = partition(arr, low, high);

        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}


---


// 912. Sort an Array
// https://leetcode.cn/problems/sort-an-array/description/

void quickSort3Way(int arr[], int low, int high) {
    if (low >= high)
        return;

    int random_idx = low + rand() % (high - low + 1);
    swap(&arr[low], &arr[random_idx]);
    int pivot = arr[low];

    int lt = low;
    int gt = high;
    int i = low + 1;

    while (i <= gt) {
        if (arr[i] < pivot)
            swap(&arr[lt++], &arr[i++]);
        else if (arr[i] > pivot)
            swap(&arr[i], &arr[gt--]);
        else
            i++;
    }

    quickSort3Way(arr, low, lt - 1);
    quickSort3Way(arr, gt + 1, high);
}

vector<int> sortArray(vector<int>& nums) {
    srand(time(NULL));
    quickSort3Way(nums.data(), 0, nums.size() - 1);
    return nums;
}


---


void selectSort(int arr[], int n)
{
    for (int i = 0; i < n - 1; i++)
    {
        int min_index = i;
        for (int j = i + 1; j < n; j++)
        {
            compare_count++;
            if (arr[min_index] > arr[j])
            {
                min_index = j;
            }
        }

        if (min_index != i)
        {
            swap_count++;
            swap(&arr[i], &arr[min_index]);
        }
    }
}


---


// K&R C 2nd, sec. 3.3 Else-If

int bsearch(int arr[], int left, int right, int target)
{
    int mid = left + (right - left) / 2;

    if (left > right)
        return -1;

    if (target == arr[mid])
        return mid;
    else if (target < arr[mid])
        return bsearch(arr, left, mid - 1, target);
    else if (target > arr[mid])
        return bsearch(arr, mid + 1, right, target);

    return -1;
}


---


// K&R C 2nd, sec. 5.5 Character Pointers and Functions

// copies the string src to the string dest.
// dest=src copies the pointer, not the characters.

#include <cstdio>
#include <cstring>

void strcpy(char *dest, char *src)
{
    while (*dest++ = *src++)
        ;
}

// handle overlap with memmove
// when both src and dest point to the same character string array
//
// 1. src is after dest, copy forward normally
//          src
//           |
//     .........
//       |
//      dest
//
// 2. src is before dest, copy backward
//      src
//       |
//     .........
//           |
//          dest
//
void memmove(char *dest, const char *src, int n)
{
    if (src > dest)
    {
        // forward
        while (n-- > 0)
        {
            *dest++ = *src++;
        }
    }
    else if (src < dest)
    {
        // backward
        src += n;
        dest += n;

        while (n-- > 0)
        {
            *--dest = *--src;
        }
    }
}

int main()
{
    {
        char buffer[] = "Hello World!";
        char *src = buffer + 6;
        char *dest = buffer;
        memmove(dest, src, 5);
        printf("%s\n", buffer);
    }

    {
        char buffer[] = "Hello World!";
        char *src = buffer;
        char *dest = buffer + 6;
        memmove(dest, src, 5);
        printf("%s\n", buffer);
    }
    return 0;
}


---


// https://c-faq.com/misc/intovf.html
// integer arithmetic overflow

bool add(int a, int b, int *result)
{
    if (b < 0 && a < INT_MIN - b || b > 0 && a > INT_MAX - b)
        return false;

    *result = a + b;

    return true;
}


---


// rule of five
// https://en.cppreference.com/w/cpp/language/rule_of_three.html
// official archive: 7 June 2019

class rule_of_five
{
    char* cstring; // raw pointer used as a handle to a dynamically-allocated memory block
 public:
    rule_of_five(const char* s = "")
    : cstring(nullptr)
    {
        if (s) {
            std::size_t n = std::strlen(s) + 1;
            cstring = new char[n];      // allocate
            std::memcpy(cstring, s, n); // populate
        }
    }

    ~rule_of_five()
    {
        delete[] cstring;  // deallocate
    }

    rule_of_five(const rule_of_five& other) // copy constructor
    : rule_of_five(other.cstring)
    {}

    rule_of_five(rule_of_five&& other) noexcept // move constructor
    : cstring(std::exchange(other.cstring, nullptr))
    {}

    rule_of_five& operator=(const rule_of_five& other) // copy assignment
    {
         return *this = rule_of_five(other);
    }

    rule_of_five& operator=(rule_of_five&& other) noexcept // move assignment
    {
        std::swap(cstring, other.cstring);
        return *this;
    }

// alternatively, replace both assignment operators with
//  rule_of_five& operator=(rule_of_five other) noexcept
//  {
//      std::swap(cstring, other.cstring);
//      return *this;
//  }

};


---

