c, c++ notes

// variadic macro
// log with filename, line number source location

#define LOG(fmt, ...) printf("%s:%d: " fmt "\n", __FILE__, __LINE__, __VA_ARGS__)
LOG("%s", "");                          // portable
LOG("%s, %d, %f", "hello", 123, 3.14);  // portable

// GNU extension ##__VA_ARGS__
#define LOG(fmt, ...) printf("%s:%d: " fmt "\n", __FILE__, __LINE__, ##__VA_ARGS__)
LOG();                                  // with GNU extension
LOG("");                                // with GNU extension

main.c:10:
main.c:12: hello, 123, 3.140000


---


Quick sort

1. It selects an element as a pivot (common strategies include the first, last,
    middle, or a random element).
2. It partitions the array so that:
    - Elements less than or equal to the pivot are swapped to its left.
    - Elements greater than the pivot are swapped to its right.
    - The pivot is placed in its final sorted position.
3. It recursively applies the same process to the left and right subarrays until
    the entire array is sorted.
4. Quicksort implementations often use in-place swaps instead of insertions or
    deletions.


#include <stdio.h>

void swap(int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

// places pivot in correct position and returns its index
int partition(int arr[], int low, int high)
{
    int pivot = arr[high];
    int i = low - 1;

    for (int j = low; j < high; j++)
    {
        if (arr[j] <= pivot)
        {
            swap(&arr[++i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return i + 1;
}

void quickSort(int arr[], int low, int high)
{
    if (low < high)
    {
        // pi is partitioning index
        int pi = partition(arr, low, high);

        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

void printArray(int arr[], int size)
{
    for (int i = 0; i < size; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main()
{
    int arr[] = {10, 7, 8, 9, 1, 5};
    int n = sizeof(arr) / sizeof(arr[0]);

    printf("Original array: ");
    printArray(arr, n);

    quickSort(arr, 0, n - 1);

    printf("Sorted array: ");
    printArray(arr, n);

    return 0;
}


---


// test

#include <stdio.h>

int compare_count = 0;
int swap_count = 0;
int partition_count = 0;

void swap(int *a, int *b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

// places pivot in correct position and returns its index
int partition(int arr[], int low, int high)
{
    int pivot = arr[high];
    int i = low - 1;

    for (int j = low; j < high; j++)
    {
        compare_count++; // messure compare count
        if (arr[j] <= pivot)
        {
            swap_count++; // messure swap count
            swap(&arr[++i], &arr[j]);
        }
    }
    swap_count++; // messure swap count
    swap(&arr[i + 1], &arr[high]);
    return i + 1;
}

void quickSort(int arr[], int low, int high)
{
    if (low < high)
    {
        // pi is partitioning index
        partition_count++; // messure partition count
        int pi = partition(arr, low, high);

        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

void printArray(int arr[], int size)
{
    for (int i = 0; i < size; i++)
    {
        printf("%d ", arr[i]);
    }
    printf("\n");
}

int main()
{
    {
        int arr[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
        int n = sizeof(arr) / sizeof(arr[0]);
        compare_count = 0;
        swap_count = 0;
        partition_count = 0;
        printf("Ascending: ");
        printArray(arr, n);
        quickSort(arr, 0, n - 1);
        printf("Sorted array: ");
        printArray(arr, n);
        printf("compare_count: %d, swap_count: %d, partition_count: %d\n\n", compare_count, swap_count, partition_count);
    }

    {
        int arr[] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
        int n = sizeof(arr) / sizeof(arr[0]);
        compare_count = 0;
        swap_count = 0;
        partition_count = 0;
        printf("Descending: ");
        printArray(arr, n);
        quickSort(arr, 0, n - 1);
        printf("Sorted array: ");
        printArray(arr, n);
        printf("compare_count: %d, swap_count: %d, partition_count: %d\n\n", compare_count, swap_count, partition_count);
    }

    {
        int arr[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
        int n = sizeof(arr) / sizeof(arr[0]);
        compare_count = 0;
        swap_count = 0;
        partition_count = 0;
        printf("All equal: ");
        printArray(arr, n);
        quickSort(arr, 0, n - 1);
        printf("Sorted array: ");
        printArray(arr, n);
        printf("compare_count: %d, swap_count: %d, partition_count: %d\n\n", compare_count, swap_count, partition_count);
    }

    {
        int arr[] = {3, 7, 2, 9, 1, 5, 8, 4, 10, 6};
        int n = sizeof(arr) / sizeof(arr[0]);
        compare_count = 0;
        swap_count = 0;
        partition_count = 0;
        printf("random 1: ");
        printArray(arr, n);
        quickSort(arr, 0, n - 1);
        printf("Sorted array: ");
        printArray(arr, n);
        printf("compare_count: %d, swap_count: %d, partition_count: %d\n\n", compare_count, swap_count, partition_count);
    }

    {
        int arr[] = {7, 3, 10, 1, 5, 9, 2, 8, 4, 6};
        int n = sizeof(arr) / sizeof(arr[0]);
        compare_count = 0;
        swap_count = 0;
        partition_count = 0;
        printf("random 2: ");
        printArray(arr, n);
        quickSort(arr, 0, n - 1);
        printf("Sorted array: ");
        printArray(arr, n);
        printf("compare_count: %d, swap_count: %d, partition_count: %d\n\n", compare_count, swap_count, partition_count);
    }

    {
        int arr[] = {9, 3, 6, 2, 8, 1, 7, 4, 10, 5};
        int n = sizeof(arr) / sizeof(arr[0]);
        compare_count = 0;
        swap_count = 0;
        partition_count = 0;
        printf("random 3: ");
        printArray(arr, n);
        quickSort(arr, 0, n - 1);
        printf("Sorted array: ");
        printArray(arr, n);
        printf("compare_count: %d, swap_count: %d, partition_count: %d\n\n", compare_count, swap_count, partition_count);
    }

    return 0;
}


$ ./src/main/main
Ascending: 1 2 3 4 5 6 7 8 9 10
Sorted array: 1 2 3 4 5 6 7 8 9 10
compare_count: 45, swap_count: 54, partition_count: 9

Descending: 10 9 8 7 6 5 4 3 2 1
Sorted array: 1 2 3 4 5 6 7 8 9 10
compare_count: 45, swap_count: 29, partition_count: 9

All equal: 1 1 1 1 1 1 1 1 1 1
Sorted array: 1 1 1 1 1 1 1 1 1 1
compare_count: 45, swap_count: 54, partition_count: 9

random 1: 3 7 2 9 1 5 8 4 10 6
Sorted array: 1 2 3 4 5 6 7 8 9 10
compare_count: 20, swap_count: 17, partition_count: 6

random 2: 7 3 10 1 5 9 2 8 4 6
Sorted array: 1 2 3 4 5 6 7 8 9 10
compare_count: 19, swap_count: 17, partition_count: 5

random 3: 9 3 6 2 8 1 7 4 10 5
Sorted array: 1 2 3 4 5 6 7 8 9 10
compare_count: 21, swap_count: 18, partition_count: 7

$


---


// rule of five
// https://en.cppreference.com/w/cpp/language/rule_of_three.html
// official archive: 7 June 2019

class rule_of_five
{
    char* cstring; // raw pointer used as a handle to a dynamically-allocated memory block
 public:
    rule_of_five(const char* s = "")
    : cstring(nullptr)
    {
        if (s) {
            std::size_t n = std::strlen(s) + 1;
            cstring = new char[n];      // allocate
            std::memcpy(cstring, s, n); // populate
        }
    }

    ~rule_of_five()
    {
        delete[] cstring;  // deallocate
    }

    rule_of_five(const rule_of_five& other) // copy constructor
    : rule_of_five(other.cstring)
    {}

    rule_of_five(rule_of_five&& other) noexcept // move constructor
    : cstring(std::exchange(other.cstring, nullptr))
    {}

    rule_of_five& operator=(const rule_of_five& other) // copy assignment
    {
         return *this = rule_of_five(other);
    }

    rule_of_five& operator=(rule_of_five&& other) noexcept // move assignment
    {
        std::swap(cstring, other.cstring);
        return *this;
    }

// alternatively, replace both assignment operators with
//  rule_of_five& operator=(rule_of_five other) noexcept
//  {
//      std::swap(cstring, other.cstring);
//      return *this;
//  }

};


---

